/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((function webpackLoadOptionalExternalModule() { try { return require("moment-timezone"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("moment"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define(["moment-timezone", "moment"], factory);
	else {
		var a = typeof exports === 'object' ? factory((function webpackLoadOptionalExternalModule() { try { return require("moment-timezone"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("moment"); } catch(e) {} }())) : factory(root["moment-timezone"], root["moment"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, (__WEBPACK_EXTERNAL_MODULE_moment_timezone__, __WEBPACK_EXTERNAL_MODULE_moment__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Formatter.ts":
/*!**************************!*\
  !*** ./src/Formatter.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Formatter: () => (/* binding */ Formatter),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   findAbbreviationForOffset: () => (/* binding */ findAbbreviationForOffset),\n/* harmony export */   getDescriptionForAbbreviation: () => (/* binding */ getDescriptionForAbbreviation),\n/* harmony export */   getZoneForDateTime: () => (/* binding */ getZoneForDateTime),\n/* harmony export */   toAbsString: () => (/* binding */ toAbsString),\n/* harmony export */   zeroPad: () => (/* binding */ zeroPad)\n/* harmony export */ });\n/* harmony import */ var _abbreviations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abbreviations */ \"./src/abbreviations.ts\");\n/* eslint-disable @typescript-eslint/ban-types */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n//import { Moment } from 'moment-timezone';\n\nconst offsetMappings = {};\nconst findAbbreviationForOffset = offset => {\n  if (!moment.tz) {\n    return null;\n  }\n  const tz = moment.tz.guess();\n  const short = tz ? moment.tz(tz).format(\"z\") : null;\n  //  console.log('guessed=', short);\n\n  const matches = _abbreviations__WEBPACK_IMPORTED_MODULE_0__.offsets[String(offset)];\n  if (matches) {\n    // check if the current browser zone matches our offset mapping\n    // and if so, shortcut to that abbreviation\n    if (matches.indexOf(short) >= 0) {\n      return short;\n    } else {\n      // otherwise, return the first/primary abbreviation in the offset mapping\n      return matches[0];\n    }\n  }\n  return null;\n};\nconst getDescriptionForAbbreviation = abbr => {\n  if (_abbreviations__WEBPACK_IMPORTED_MODULE_0__.abbreviations[abbr]) {\n    return _abbreviations__WEBPACK_IMPORTED_MODULE_0__.abbreviations[abbr];\n  }\n  return null;\n};\nconst getZoneForDateTime = dateTime => {\n  const dt = moment(dateTime);\n  const offset = dt.utcOffset();\n  if (!offsetMappings[offset]) {\n    const shortcut = findAbbreviationForOffset(offset);\n    if (shortcut) {\n      offsetMappings[offset] = shortcut;\n    } else {\n      console.warn(\"- unhandled offset: \" + offset);\n    }\n  }\n  return offsetMappings[offset] || null;\n};\nconst toAbsString = value => {\n  if (Number.isInteger(value)) {\n    return String(Math.abs(value));\n  }\n  return value.replace(/^-/, \"\");\n};\nconst zeroPad = (input, length) => {\n  const abs = toAbsString(input);\n  // never truncate, just return if it's bigger\n  if (abs.length >= length) {\n    return String(input);\n  }\n  return (abs !== input ? \"-\" : \"\") + (\"0\".repeat(length) + abs).substr(0 - length);\n};\nclass Token {\n  count = 0;\n  constructor(value, count) {\n    if (value.length != 1) {\n      throw new Error(\"You must provide a single character when creating a token!\");\n    }\n    this.token = value;\n    this.count = count === undefined ? 1 : count;\n  }\n  increment() {\n    this.count++;\n    return this.count;\n  }\n  equals(token) {\n    return this.token === token.token && this.count === token.count;\n  }\n  toString() {\n    return this.token.repeat(this.count);\n  }\n}\nclass Formatter {}\n\n//# sourceURL=webpack://@rangerrick/moment-javaformat/./src/Formatter.ts?");

/***/ }),

/***/ "./src/abbreviations.ts":
/*!******************************!*\
  !*** ./src/abbreviations.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abbreviations: () => (/* binding */ abbreviations),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   offsets: () => (/* binding */ offsets)\n/* harmony export */ });\n/*\n// Java 8 mappings:\nEST - -05:00\nHST - -10:00\nMST - -07:00\nACT - Australia/Darwin\nAET - Australia/Sydney\nAGT - America/Argentina/Buenos_Aires\nART - Africa/Cairo\nAST - America/Anchorage\nBET - America/Sao_Paulo\nBST - Asia/Dhaka\nCAT - Africa/Harare\nCNT - America/St_Johns\nCST - America/Chicago\nCTT - Asia/Shanghai\nEAT - Africa/Addis_Ababa\nECT - Europe/Paris\nIET - America/Indiana/Indianapolis\nIST - Asia/Kolkata\nJST - Asia/Tokyo\nMIT - Pacific/Apia\nNET - Asia/Yerevan\nNST - Pacific/Auckland\nPLT - Asia/Karachi\nPNT - America/Phoenix\nPRT - America/Puerto_Rico\nPST - America/Los_Angeles\nSST - Pacific/Guadalcanal\nVST - Asia/Ho_Chi_Minh\n*/\n\nconst offsets = {\n  \"-720\": [\"AoE\", \"Y\"],\n  // -12\n  \"-660\": [\"NUT\", \"SST\", \"X\"],\n  // -11\n  \"-600\": [\"HST\", \"CKT\", \"TAHT\", \"W\"],\n  // -10\n  \"-570\": [\"MART\"],\n  // -9:30\n  \"-540\": [\"AKST\", \"HDT\", \"GAMT\", \"V\"],\n  // -9\n  \"-480\": [\"PST\", \"AKDT\", \"U\", \"PT\"],\n  // -8\n  \"-420\": [\"MST\", \"PDT\", \"T\", \"MT\", \"PT\"],\n  // -7\n  \"-360\": [\"CST\", \"MDT\", \"EAST\", \"GALT\", \"S\", \"CT\", \"MT\"],\n  // -6\n  \"-300\": [\"EST\", \"CDT\", \"ACT\", \"CIST\", \"COT\", \"CST\", \"EASST\", \"ECT\", \"PET\", \"R\", \"ET\", \"CT\"],\n  // -5\n  \"-240\": [\"EDT\", \"AST\", \"AMT\", \"BOT\", \"CIDST\", \"CLT\", \"FKT\", \"GYT\", \"VET\", \"Q\", \"AT\", \"ET\"],\n  // -4\n  \"-210\": [\"NST\"],\n  // -3:30\n  \"-180\": [\"UYT\", \"ADT\", \"AMST\", \"ART\", \"BRT\", \"CLST\", \"FKST\", \"GFT\", \"PMST\", \"ROTT\", \"SRT\", \"UYT\", \"WARST\", \"WGT\", \"P\", \"AT\"],\n  // -3\n  \"-150\": [\"NDT\"],\n  // -2:30\n  \"-120\": [\"GST\", \"BRST\", \"FNT\", \"GST\", \"PMDT\", \"UYST\", \"WGST\", \"O\"],\n  // -2\n  \"-60\": [\"CVT\", \"AZOT\", \"CVT\", \"EGT\", \"N\"],\n  // -1\n  \"0\": [\"UTC\", \"GMT\", \"AZOST\", \"EGST\", \"WET\", \"Z\", \"WT\"],\n  // +/-0\n  \"60\": [\"CET\", \"BST\", \"WAT\", \"WEST\", \"WST\", \"A\"],\n  // +1\n  \"120\": [\"CAT\", \"CEST\", \"EET\", \"SAST\", \"WAST\", \"B\"],\n  // +2\n  \"180\": [\"EAT\", \"EEST\", \"FET\", \"MSK\", \"SYOT\", \"TRT\", \"C\"],\n  // +3\n  \"210\": [\"IRST\"],\n  // +3:30\n  \"240\": [\"GET\", \"AZT\", \"KUYT\", \"MSD\", \"MUT\", \"RET\", \"SAMT\", \"SCT\", \"D\"],\n  // +4\n  \"270\": [\"AFT\", \"IRDT\"],\n  // +4:30\n  \"300\": [\"UZT\", \"AQTT\", \"AZST\", \"MAWT\", \"MVT\", \"ORAT\", \"PKT\", \"TFT\", \"TJT\", \"TMT\", \"YEKT\", \"E\"],\n  // +5\n  \"330\": [\"IST\"],\n  // +5:30\n  \"345\": [\"NPT\"],\n  // +5:45\n  \"360\": [\"BTT\", \"ALMT\", \"BTT\", \"IOT\", \"KGT\", \"OMST\", \"QYZT\", \"VOST\", \"YEKST\", \"F\"],\n  // +6\n  \"390\": [\"MMT\", \"CCT\"],\n  // +6:30\n  \"420\": [\"ICT\", \"CXT\", \"DAVT\", \"HOVT\", \"KRAT\", \"NOVST\", \"NOVT\", \"OMSST\", \"WIB\", \"G\"],\n  // +7\n  \"480\": [\"HKT\", \"AWST\", \"BNT\", \"CAST\", \"CHOT\", \"HOVST\", \"IRKT\", \"KRAST\", \"MYT\", \"PHT\", \"SGT\", \"ULAT\", \"WITA\", \"H\"],\n  // +8\n  \"510\": [\"PYT\"],\n  // +8:30\n  \"525\": [\"ACWST\"],\n  // +8:45\n  \"540\": [\"JST\", \"AWDT\", \"CHOST\", \"IRKST\", \"KST\", \"PWT\", \"TLT\", \"ULAST\", \"WIT\", \"YAKT\", \"I\"],\n  // +9\n  \"570\": [\"ACST\", \"ACT\"],\n  // +9:30\n  \"600\": [\"PGT\", \"AEST\", \"CHUT\", \"ChST\", \"DDUT\", \"VLAT\", \"YAKST\", \"YAPT\", \"K\", \"AET\"],\n  // +10\n  \"630\": [\"ACDT\", \"LHST\", \"ACT\"],\n  // +10:30\n  \"660\": [\"VUT\", \"AEDT\", \"KOST\", \"LHDT\", \"MAGT\", \"NCT\", \"NFT\", \"PONT\", \"SAKT\", \"SBT\", \"SRET\", \"VLAST\", \"L\", \"AET\"],\n  // +11\n  \"720\": [\"FJT\", \"ANAST\", \"ANAT\", \"GILT\", \"MAGST\", \"MHT\", \"NFDT\", \"NRT\", \"NZST\", \"PETST\", \"PETT\", \"TVT\", \"WAKT\", \"WFT\", \"M\"],\n  // +12\n  \"765\": [\"CHAST\"],\n  // +12:45\n  \"780\": [\"TOT\", \"FJST\", \"NZDT\", \"PHOT\", \"TKT\", \"TOT\"],\n  // +13\n  \"825\": [\"CHADT\"],\n  // +13:45\n  \"840\": [\"LINT\", \"TOST\", \"WST\"] // +14\n};\n\nconst abbreviations = {\n  A: \"Alpha Time Zone\",\n  ACDT: \"Australian Central Daylight Time\",\n  ACST: \"Australian Central Standard Time\",\n  //  ACT: 'Acre Time',\n  ACT: \"Australian Central Time\",\n  ACWST: \"Australian Central Western Standard Time\",\n  //  ADT: 'Arabia Daylight Time',\n  ADT: \"Atlantic Daylight Time\",\n  ADST: \"Atlantic Daylight Saving Time\",\n  AEDT: \"Australian Eastern Daylight Time\",\n  AEST: \"Australian Eastern Standard Time\",\n  AET: \"Australian Eastern Time\",\n  AFT: \"Afghanistan Time\",\n  AKDT: \"Alaska Daylight Time\",\n  AKST: \"Alaska Standard Time\",\n  ALMT: \"Alma-Ata Time\",\n  AMDT: \"Armenia Daylight Time\",\n  AMST: \"Amazon Summer Time\",\n  //  AMST: 'Armenia Summer Time',\n  AMT: \"Amazon Time\",\n  //  AMT: 'Armenia Time',\n  ANAST: \"Anadyr Summer Time\",\n  ANAT: \"Anadyr Time\",\n  AQTT: \"Aqtobe Time\",\n  ART: \"Argentina Time\",\n  //  AST: 'Arabia Standard Time',\n  AST: \"Atlantic Standard Time\",\n  AT: \"Atlantic Time\",\n  AWDT: \"Australian Western Daylight Time\",\n  AWST: \"Australian Western Standard Time\",\n  AZODT: \"Azores Daylight Time\",\n  AZOST: \"Azores Summer Time\",\n  AZOT: \"Azores Time\",\n  AZST: \"Azerbaijan Summer Time\",\n  AZT: \"Azerbaijan Time\",\n  AoE: \"Anywhere on Earth\",\n  B: \"Bravo Time Zone\",\n  BDST: \"British Daylight Saving Time\",\n  //  BDT: 'British Daylight Time',\n  BDT: \"Brunei Time\",\n  BNT: \"Brunei Darussalam Time\",\n  BOT: \"Bolivia Time\",\n  BRST: \"Brasília Summer Time\",\n  BRT: \"Brasília Time\",\n  //  BST: 'Bangladesh Standard Time',\n  //  BST: 'Bougainville Standard Time',\n  BST: \"British Summer Time\",\n  BT: \"Brazil Time\",\n  BTT: \"Bhutan Time\",\n  C: \"Charlie Time Zone\",\n  CAST: \"Casey Time\",\n  CAT: \"Central Africa Time\",\n  CCT: \"Cocos Islands Time\",\n  CDT: \"Central Daylight Time\",\n  //  CDT: 'Cuba Daylight Time',\n  CDST: \"Central Daylight Savings Time\",\n  CEDT: \"Central European Daylight Time\",\n  CEST: \"Central European Summer Time\",\n  CET: \"Central European Time\",\n  CHADT: \"Chatham Island Daylight Time\",\n  CHAST: \"Chatham Island Standard Time\",\n  CHODT: \"Choibalsan Daylight Time\",\n  CHODST: \"Choibalsan Daylight Saving Time\",\n  CHOST: \"Choibalsan Summer Time\",\n  CHOT: \"Choibalsan Time\",\n  CHUT: \"Chuuk Time\",\n  CIDST: \"Cayman Islands Daylight Saving Time\",\n  CIST: \"Cayman Islands Standard Time\",\n  CIT: \"Cayman Islands Time\",\n  CKT: \"Cook Island Time\",\n  CLDT: \"Chile Daylight Time\",\n  CLST: \"Chile Summer Time\",\n  CLT: \"Chile Standard Time\",\n  COT: \"Colombia Time\",\n  CST: \"Central Standard Time\",\n  //  CST: 'China Standard Time',\n  //  CST: 'Cuba Standard Time',\n  CT: \"Central Time\",\n  CVT: \"Cape Verde Time\",\n  CXT: \"Christmas Island Time\",\n  ChST: \"Chamorro Standard Time\",\n  D: \"Delta Time Zone\",\n  DAVT: \"Davis Time\",\n  DDUT: \"Dumont-d'Urville Time\",\n  E: \"Echo Time Zone\",\n  EADT: \"Easter Island Daylight Time\",\n  EASST: \"Easter Island Summer Time\",\n  EAST: \"Easter Island Standard Time\",\n  EAT: \"Eastern Africa Time\",\n  ECST: \"European Central Summer Time\",\n  ECT: \"Ecuador Time\",\n  EDT: \"Eastern Daylight Time\",\n  EDST: \"Eastern Daylight Saving Time\",\n  EEDT: \"Eastern European Daylight Time\",\n  EEST: \"Eastern European Summer Time\",\n  EET: \"Eastern European Time\",\n  EFATE: \"Efate Time\",\n  EGST: \"Eastern Greenland Summer Time\",\n  EGT: \"East Greenland Time\",\n  EST: \"Eastern Standard Time\",\n  ET: \"Eastern Time\",\n  F: \"Foxtrot Time Zone\",\n  FET: \"Further-Eastern European Time\",\n  FJDT: \"Fiji Daylight Time\",\n  FJST: \"Fiji Summer Time\",\n  FJT: \"Fiji Time\",\n  FKDT: \"Falkland Island Daylight Time\",\n  FKST: \"Falkland Islands Summer Time\",\n  FKT: \"Falkland Island Time\",\n  FNT: \"Fernando de Noronha Time\",\n  G: \"Golf Time Zone\",\n  GALT: \"Galapagos Time\",\n  GAMT: \"Gambier Time\",\n  GET: \"Georgia Standard Time\",\n  GFT: \"French Guiana Time\",\n  GILT: \"Gilbert Island Time\",\n  GMT: \"Greenwich Mean Time\",\n  //  GST: 'Gulf Standard Time',\n  GST: \"South Georgia Time\",\n  GT: \"Greenwich Time\",\n  GYT: \"Guyana Time\",\n  H: \"Hotel Time Zone\",\n  HAA: \"Heure Avancée de l'Atlantique\",\n  HAC: \"Heure Avancée du Centre\",\n  HADT: \"Hawaii Daylight Time\",\n  HAE: \"Heure Avancée de l'Est\",\n  HAP: \"Heure Avancée du Pacifique\",\n  HAST: \"Hawaii-Aleutian Standard Time\",\n  HAR: \"Heure Avancée des Rocheuses\",\n  HAT: \"Heure Avancée de Terre-Neuve\",\n  HDT: \"Hawaii-Aleutian Daylight Time\",\n  HLV: \"Hora Legal de Venezuela\",\n  HNA: \"Heure Normale de l'Atlantique\",\n  HNC: \"Heure Normale du Centre\",\n  HNE: \"Heure Normale de l'Est\",\n  HNP: \"Heure Normale du Pacifique\",\n  HNR: \"Heure Normale des Rocheuses\",\n  HNT: \"Heure Normale de Terre-Neuve\",\n  HKT: \"Hong Kong Time\",\n  HOVDT: \"Hovd Daylight Time\",\n  HOVDST: \"Hovd Daylight Saving Time\",\n  HOVST: \"Hovd Summer Time\",\n  HOVT: \"Hovd Time\",\n  HST: \"Hawaii Standard Time\",\n  I: \"India Time Zone\",\n  ICT: \"Indochina Time\",\n  IDT: \"Israel Daylight Time\",\n  IOT: \"Indian Chagos Time\",\n  IRDT: \"Iran Daylight Time\",\n  IRKST: \"Irkutsk Summer Time\",\n  IRKT: \"Irkutsk Time\",\n  IRST: \"Iran Standard Time\",\n  IST: \"India Standard Time\",\n  //  IST: 'Irish Standard Time',\n  //  IST: 'Israel Standard Time',\n  JST: \"Japan Standard Time\",\n  K: \"Kilo Time Zone\",\n  KGT: \"Kyrgyzstan Time\",\n  KIT: \"Kerguelen (Islands) Time\",\n  KOST: \"Kosrae Time\",\n  KRAST: \"Krasnoyarsk Summer Time\",\n  KRAT: \"Krasnoyarsk Time\",\n  KST: \"Korea Standard Time\",\n  KT: \"Korea Time\",\n  KUYT: \"Kuybyshev Time\",\n  L: \"Lima Time Zone\",\n  LHDT: \"Lord Howe Daylight Time\",\n  LHST: \"Lord Howe Standard Time\",\n  LINT: \"Line Islands Time\",\n  M: \"Mike Time Zone\",\n  MAGST: \"Magadan Summer Time\",\n  MAGT: \"Magadan Time\",\n  MART: \"Marquesas Time\",\n  MAWT: \"Mawson Time\",\n  MCK: \"Moscow Time\",\n  MDST: \"Mountain Daylight Saving Time\",\n  MDT: \"Mountain Daylight Time\",\n  MESZ: \"Mitteleuropäische Sommerzeit\",\n  MEZ: \"Mitteleuropäische Zeit\",\n  MHT: \"Marshall Islands Time\",\n  MMT: \"Myanmar Time\",\n  MST: \"Mountain Standard Time\",\n  MSK: \"Moscow Standard Time\",\n  MT: \"Mountain Time\",\n  MUT: \"Mauritius Time\",\n  MVT: \"Maldives Time\",\n  MYT: \"Malaysia Time\",\n  N: \"November Time Zone\",\n  NACDT: \"North American Central Daylight Time\",\n  NACST: \"North American Central Standard Time\",\n  NAEDT: \"North American Eastern Daylight Time\",\n  NAEST: \"North American Eastern Standard Time\",\n  NAMDT: \"North American Mountain Daylight Time\",\n  NAMST: \"North American Mountain Standard Time\",\n  NAPDT: \"North American Pacific Daylight Time\",\n  NAPST: \"North American Pacific Standard Time\",\n  NCT: \"New Caledonia Time\",\n  NDT: \"Newfoundland Daylight Time\",\n  NFDT: \"Norfolk Daylight Time\",\n  NFT: \"Norfolk Time\",\n  NOVST: \"Novosibirsk Summer Time\",\n  NOVT: \"Novosibirsk Time\",\n  NPT: \"Nepal Time\",\n  NRT: \"Nauru Time\",\n  NST: \"Newfoundland Standard Time\",\n  NUT: \"Niue Time\",\n  NZDT: \"New Zealand Daylight Time\",\n  NZST: \"New Zealand Standard Time\",\n  O: \"Oscar Time Zone\",\n  OESZ: \"Osteuropäische Sommerzeit\",\n  OEZ: \"Osteuropäische Zeit\",\n  OMSST: \"Omsk Summer Time\",\n  OMST: \"Omsk Standard Time\",\n  ORAT: \"Oral Time\",\n  P: \"Papa Time Zone\",\n  PDT: \"Pacific Daylight Time\",\n  PDST: \"Pacific Daylight Saving Time\",\n  PET: \"Peru Time\",\n  PETST: \"Kamchatka Summer Time\",\n  PETT: \"Kamchatka Time\",\n  PGT: \"Papua New Guinea Time\",\n  PHOT: \"Phoenix Island Time\",\n  PHT: \"Philippine Time\",\n  PKT: \"Pakistan Standard Time\",\n  PMDT: \"Pierre & Miquelon Daylight Time\",\n  PMST: \"Pierre & Miquelon Standard Time\",\n  PONT: \"Pohnpei Standard Time\",\n  PST: \"Pacific Standard Time\",\n  //  PST: 'Pitcairn Standard Time',\n  PT: \"Pacific Time\",\n  PWT: \"Palau Time\",\n  //  PYST: 'Paraguay Summer Time',\n  PYST: \"Pyongyang Standard Time\",\n  //  PYT: 'Paraguay Time',\n  PYT: \"Pyongyang Time\",\n  Q: \"Quebec Time Zone\",\n  QYZT: \"Qyzylorda Time\",\n  R: \"Romeo Time Zone\",\n  RET: \"Reunion Time\",\n  ROTT: \"Rothera Time\",\n  S: \"Sierra Time Zone\",\n  SAKT: \"Sakhalin Time\",\n  SAMT: \"Samara Time\",\n  SAMST: \"Samara Summer Time\",\n  SAST: \"South Africa Standard Time\",\n  SBT: \"Solomon Islands Time\",\n  SCT: \"Seychelles Time\",\n  SGT: \"Singapore Time\",\n  SRET: \"Srednekolymsk Time\",\n  SRT: \"Suriname Time\",\n  SST: \"Samoa Standard Time\",\n  SYOT: \"Syowa Time\",\n  T: \"Tango Time Zone\",\n  TAHT: \"Tahiti Time\",\n  TFT: \"French Southern and Antarctic Time\",\n  TJT: \"Tajikistan Time\",\n  TKT: \"Tokelau Time\",\n  TLT: \"East Timor Time\",\n  TMT: \"Turkmenistan Time\",\n  TOST: \"Tonga Summer Time\",\n  TOT: \"Tonga Time\",\n  TRT: \"Turkey Time\",\n  tVT: \"Tuvalu Time\",\n  U: \"Uniform Time Zone\",\n  ULAST: \"Ulaanbaatar Summer Time\",\n  ULAT: \"Ulaanbaatar Time\",\n  UTC: \"Coordinated Universal Time\",\n  UYST: \"Uruguay Summer Time\",\n  UYT: \"Uruguay Time\",\n  UZT: \"Uzbekistan Time\",\n  V: \"Victor Time Zone\",\n  VET: \"Venezuelan Standard Time\",\n  VLAST: \"Vladivostok Summer Time\",\n  VLAT: \"Vladivostok Time\",\n  VOST: \"Vostok Time\",\n  VUT: \"Vanuatu Time\",\n  W: \"Whiskey Time Zone\",\n  WAKT: \"Wake Time\",\n  WARST: \"Western Argentine Summer Time\",\n  WAST: \"West Africa Summer Time\",\n  //  WAT: 'Western Australia Time',\n  WAT: \"West Africa Time\",\n  //  WAT: 'Western Australia Time',\n  WDT: \"Western Daylight Time\",\n  WEDT: \"Western European Daylight Time\",\n  WEST: \"Western European Summer Time\",\n  WESZ: \"Westeuropäische Sommerzeit\",\n  WET: \"Western European Time\",\n  WEZ: \"Westeuropäische Zeit\",\n  WFT: \"Wallis and Futuna Time\",\n  WGST: \"Western Greenland Summer Time\",\n  WGT: \"West Greenland Time\",\n  WIB: \"Western Indonesian Time\",\n  WIT: \"Eastern Indonesian Time\",\n  WITA: \"Central Indonesian Time\",\n  WST: \"Western Standard Time\",\n  //  WST: 'West Samoa Time',\n  //  WST: 'Western Summer Time',\n  WT: \"Western Sahara Standard Time\",\n  X: \"X-ray Time Zone\",\n  Y: \"Yankee Time Zone\",\n  YAKST: \"Yakutsk Summer Time\",\n  YAKT: \"Yakutsk Time\",\n  YAPT: \"Yap Time\",\n  YEKST: \"Yekaterinburg Summer Time\",\n  YEKT: \"Yekaterinburg Time\",\n  Z: \"Zulu Time Zone\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (abbreviations);\n\n//# sourceURL=webpack://@rangerrick/moment-javaformat/./src/abbreviations.ts?");

/***/ }),

/***/ "./src/formats/DateTimeFormatter.ts":
/*!******************************************!*\
  !*** ./src/formats/DateTimeFormatter.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PaddedToken: () => (/* binding */ PaddedToken),\n/* harmony export */   \"default\": () => (/* binding */ DateTimeFormatter)\n/* harmony export */ });\n/* harmony import */ var _Formatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Formatter */ \"./src/Formatter.ts\");\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n//import { Moment } from 'moment-timezone';\n\n\nconst endZeroes = /:?00$/;\nconst matchReserved = /[A-Za-z]/;\nconst adConverter = moment => {\n  return moment.year() > 0 ? \"AD\" : \"BC\";\n};\nconst findAbbreviation = moment => {\n  const defaultAbbr = moment.zoneAbbr();\n  if (defaultAbbr === \"UTC\" && moment.utcOffset() != 0) {\n    return null;\n  }\n  return defaultAbbr;\n};\nconst javaToMoment = {\n  // era\n  G: adConverter,\n  GG: adConverter,\n  GGG: adConverter,\n  GGGG: moment => {\n    return moment.year() > 0 ? \"Anno Domini\" : \"Before Christ\";\n  },\n  GGGGG: moment => {\n    return adConverter(moment).substring(0, 1);\n  },\n  // year\n  u: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"YYYY\"), 1);\n  },\n  uu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YY\")), 2);\n  },\n  uuu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"YYYY\"), 3);\n  },\n  uuuu: \"YYYY\",\n  uuuuu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"YYYY\"), 5);\n  },\n  uuuuuu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"YYYY\"), 6);\n  },\n  // year-of-era\n  y: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"Y\"));\n  },\n  yy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YY\"));\n  },\n  yyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\")), 3);\n  },\n  yyyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\"));\n  },\n  yyyyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\")), 5);\n  },\n  yyyyyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\")), 6);\n  },\n  // day-of-year\n  D: \"DDD\",\n  DD: moment => {\n    const ret = moment.format(\"DDD\");\n    if (ret.length > 2) {\n      throw new Error(\"Field DayOfYear cannot be printed as the value \" + ret + \" exceeds the maximum print width of 2\");\n    }\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(ret, 2);\n  },\n  DDD: \"DDDD\",\n  // DDDD throws an error in Java DateTimeFormatter\n\n  // month-of-year\n  M: \"M\",\n  MM: \"MM\",\n  MMM: \"MMM\",\n  MMMM: \"MMMM\",\n  MMMMM: moment => {\n    return moment.format(\"MMMM\").substring(0, 1);\n  },\n  // month-of-year (numeric)\n  L: \"M\",\n  LL: \"MM\",\n  LLL: \"M\",\n  LLLL: \"M\",\n  LLLLL: \"M\",\n  // day-of-month\n  d: \"D\",\n  dd: \"DD\",\n  // quarter-of-year\n  Q: \"Q\",\n  QQ: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"Q\"), 2);\n  },\n  QQQ: moment => {\n    return \"Q\" + moment.format(\"Q\");\n  },\n  QQQQ: moment => {\n    return moment.format(\"Qo\") + \" quarter\";\n  },\n  QQQQQ: \"Q\",\n  // quarter-of-year\n  q: \"Q\",\n  qq: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"Q\"), 2);\n  },\n  qqq: \"Q\",\n  qqqq: \"Q\",\n  qqqqq: \"Q\",\n  // week-based-year\n  Y: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"gggg\"), 1);\n  },\n  YY: \"gg\",\n  YYY: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"gggg\"), 3);\n  },\n  YYYY: \"gggg\",\n  YYYYY: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"gggg\"), 5);\n  },\n  YYYYYY: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"gggg\"), 6);\n  },\n  // week-of-week-based-year\n  w: \"w\",\n  ww: \"ww\",\n  // week-of-month (W) not supported\n  W: null,\n  WW: null,\n  WWW: null,\n  WWWW: null,\n  // day-of-week\n  E: \"ddd\",\n  EE: \"ddd\",\n  EEE: \"ddd\",\n  EEEE: \"dddd\",\n  EEEEE: moment => {\n    return moment.format(\"dddd\").substring(0, 1);\n  },\n  // localized day-of-week (e)\n  e: \"d\",\n  ee: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"d\"), 2);\n  },\n  eee: \"ddd\",\n  eeee: \"dddd\",\n  eeeee: moment => {\n    return moment.format(\"dddd\").substring(0, 1);\n  },\n  // localized day-of-week (c)\n  c: \"d\",\n  ccc: \"ddd\",\n  cccc: \"dddd\",\n  ccccc: moment => {\n    // 5 c's = 0-indexed I guess?!?\n    return String(parseInt(moment.format(\"d\"), 10) - 1);\n  },\n  // week of month (F) not supported\n\n  // am-pm-of-day\n  a: \"A\",\n  // clock-hour-of-am-pm\n  h: \"h\",\n  hh: \"hh\",\n  // hour-of-am-pm\n  K: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.hour() % 12);\n  },\n  KK: moment => {\n    const hour = (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.hour() % 12);\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(hour, 2);\n  },\n  // clock-hour-of-am-pm\n  k: \"k\",\n  kk: \"kk\",\n  // hour-of-day\n  H: \"H\",\n  HH: \"HH\",\n  // minute-of-hour\n  m: \"m\",\n  mm: \"mm\",\n  // second-of-minute\n  s: \"s\",\n  ss: \"ss\",\n  // fraction-of-second\n  S: \"S\",\n  SS: \"SS\",\n  SSS: \"SSS\",\n  SSSS: \"SSSS\",\n  SSSSS: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"SSSS\"), 5);\n  },\n  SSSSSS: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"SSSS\"), 6);\n  },\n  // milli-of-day\n  A: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.valueOf() - moment.clone().startOf(\"day\").valueOf(), 1);\n  },\n  AA: moment => {\n    if (moment.isSame(moment.clone().startOf(\"day\"))) {\n      // console.warn(moment.format() + ' is the same as ' + moment.clone().startOf('day').format());\n      return \"00\";\n    }\n    return null;\n  },\n  AAA: moment => {\n    if (moment.isSame(moment.clone().startOf(\"day\"))) {\n      return \"000\";\n    }\n    return null;\n  },\n  AAAA: moment => {\n    if (moment.isSame(moment.clone().startOf(\"day\"))) {\n      return \"0000\";\n    }\n    return null;\n  },\n  AAAAA: moment => {\n    if (moment.isSame(moment.clone().startOf(\"day\"))) {\n      return \"00000\";\n    }\n    return null;\n  },\n  AAAAAA: moment => {\n    if (moment.isSame(moment.clone().startOf(\"day\"))) {\n      return \"000000\";\n    }\n    return null;\n  },\n  // nano-of-second (n) not supported\n\n  // nano-of-day (N) not supported\n\n  // time-zone ID\n  VV: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    const tz = moment.tz();\n    if (tz && tz.length > 0) {\n      return tz;\n    }\n    return moment.format(\"Z\");\n  },\n  // time-zone name\n  z: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    const abbr = findAbbreviation(moment);\n    if (abbr) {\n      return abbr;\n    }\n    return moment.format(\"Z\");\n  },\n  zz: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    const abbr = findAbbreviation(moment);\n    if (abbr) {\n      return abbr;\n    }\n    return moment.format(\"Z\");\n  },\n  zzz: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    const abbr = findAbbreviation(moment);\n    if (abbr) {\n      return abbr;\n    }\n    return moment.format(\"Z\");\n  },\n  zzzz: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    const abbr = findAbbreviation(moment);\n    if (abbr) {\n      return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.getDescriptionForAbbreviation)(abbr);\n    }\n    return moment.format(\"Z\");\n  },\n  // localized zone-offset\n  O: moment => {\n    const offset = moment.utcOffset() / 60.0;\n    if (offset === 0) {\n      return \"GMT\";\n    }\n    const ret = moment.format(\"Z\").replace(endZeroes, \"\").replace(/^([+-])0/, \"$1\");\n    return \"GMT\" + ret;\n  },\n  OOOO: moment => {\n    const offset = moment.utcOffset() / 60.0;\n    if (offset === 0) {\n      return \"GMT\";\n    }\n    const ret = moment.format(\"Z\");\n    return \"GMT\" + ret;\n  },\n  // zone-offset 'Z' for zero\n  X: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    const ret = moment.format(\"ZZ\");\n    if (ret.match(endZeroes)) {\n      return ret.substr(0, 3);\n    }\n    return ret;\n  },\n  XX: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"ZZ\");\n  },\n  XXX: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"Z\");\n  },\n  XXXX: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"ZZ\");\n  },\n  XXXXX: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"Z\");\n  },\n  // zone-offset\n  x: moment => {\n    const ret = moment.format(\"ZZ\");\n    if (ret.match(endZeroes)) {\n      return ret.substr(0, 3);\n    }\n    return ret;\n  },\n  xx: \"ZZ\",\n  xxx: \"Z\",\n  xxxx: \"ZZ\",\n  xxxxx: \"Z\",\n  // zone-offset\n  Z: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"+0000\";\n    }\n    return moment.format(\"ZZ\");\n  },\n  ZZ: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"+0000\";\n    }\n    return moment.format(\"ZZ\");\n  },\n  ZZZ: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"+0000\";\n    }\n    return moment.format(\"ZZ\");\n  },\n  ZZZZ: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"GMT\";\n    }\n    return \"GMT\" + moment.format(\"Z\");\n  },\n  ZZZZZ: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"Z\");\n  }\n};\nclass PaddedToken extends _Formatter__WEBPACK_IMPORTED_MODULE_0__.Token {\n  constructor(padding, padChar, value, count) {\n    super(value, count);\n    this.padding = padding;\n    this.padChar = padChar;\n  }\n  format(input) {\n    if (input.length > this.padding) {\n      throw new Error(`Cannot format padding as formatted string \"${input}\" exceeds pad width of ${this.padding}.`);\n    }\n    const padded = this.padChar.repeat(this.padding) + input;\n    return padded.substr(0 - this.padding);\n  }\n}\nclass DateTimeFormatter extends _Formatter__WEBPACK_IMPORTED_MODULE_0__.Formatter {\n  tokenize(formatString) {\n    let padNextWidth = 0;\n    let padNextChar = \" \";\n    const ret = [];\n    for (let pos = 0; pos < formatString.length; pos++) {\n      let cur = formatString.charAt(pos);\n      if (cur.match(matchReserved)) {\n        let start = pos++;\n        for (; pos < formatString.length && formatString.charAt(pos) === cur; pos++);\n        let count = pos - start;\n\n        // padding parsed\n        if (cur === \"p\") {\n          let pad = 0;\n          if (pos < formatString.length) {\n            cur = formatString.charAt(pos);\n            if (cur.match(matchReserved)) {\n              pad = count;\n              start = pos++;\n              for (; pos < formatString.length && formatString.charAt(pos) === cur; pos++); // short loop\n              count = pos - start;\n            }\n          }\n          if (pad === 0) {\n            throw new Error(\"Pad letter 'p' must be followed by valid pad pattern: \" + formatString);\n          }\n          // pad and continue parsing\n          padNextWidth = pad;\n          padNextChar = \" \";\n        }\n\n        // main rules\n        const translate = javaToMoment[cur.repeat(count)];\n        if (translate === null) {\n          throw new Error(`'${cur.repeat(count)}' cannot be converted to a moment format token; token is not implemented`);\n        } else if (translate === undefined) {\n          throw new Error(`'${cur.repeat(count)}' cannot be converted to a moment format token; unknown token`);\n        } else {\n          if (padNextWidth > 0) {\n            ret.push(new PaddedToken(padNextWidth, padNextChar, cur, count));\n            padNextWidth = 0;\n            padNextChar = \" \";\n          } else {\n            ret.push(new _Formatter__WEBPACK_IMPORTED_MODULE_0__.Token(cur, count));\n          }\n        }\n        pos--;\n      } else if (cur === \"'\") {\n        // parse literals\n        const start = pos++;\n        for (; pos < formatString.length; pos++) {\n          if (formatString.charAt(pos) === \"'\") {\n            if (pos + 1 < formatString.length && formatString.charAt(pos + 1) === \"'\") {\n              pos++;\n            } else {\n              break; // end of literal\n            }\n          }\n        }\n\n        if (pos >= formatString.length) {\n          throw new Error(`Pattern ends with an incomplete string literal: ${formatString}`);\n        }\n        const str = formatString.substring(start + 1, pos);\n        if (str.length == 0) {\n          ret.push(\"'\");\n        } else {\n          ret.push(str.replace(\"''\", \"'\"));\n        }\n      } else if (cur === \"[\") {\n        throw new Error(`Optional patterns are not supported: ${cur}`);\n      } else if (cur === \"]\") {\n        throw new Error(`Optional patterns are not supported: ${cur}`);\n      } else if (cur === \"{\" || cur === \"}\" || cur === \"#\") {\n        throw new Error(`Pattern includes reserved character: '${cur}'`);\n      } else {\n        if (ret[ret.length - 1] instanceof _Formatter__WEBPACK_IMPORTED_MODULE_0__.Token) {\n          ret.push(cur);\n        } else {\n          ret[ret.length - 1] += cur;\n        }\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Convert a moment into a formatted date string, using the format tokens defined at: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n   *\n   * @param {Moment} moment - the moment to convert\n   * @param {string} formatString - the format string\n   */\n  format(moment, formatString) {\n    const parts = this.tokenize(formatString);\n    const ret = [];\n    for (const part of parts) {\n      if (part instanceof _Formatter__WEBPACK_IMPORTED_MODULE_0__.Token) {\n        const partString = part.toString();\n        const translation = javaToMoment[partString];\n        if (translation === undefined) {\n          const err = new Error(`'${partString}' cannot be converted to a moment format token; bailing`);\n          //          console.error(err.message);\n          throw err;\n        } else {\n          if (typeof translation === \"function\") {\n            const result = translation(moment, partString);\n            if (result === null) {\n              const err = new Error(`'${partString}' cannot be converted to a moment format token; bailing`);\n              //          console.error(err.message);\n              throw err;\n            }\n            ret.push(result);\n          } else {\n            ret.push(moment.format(translation));\n          }\n        }\n      } else {\n        ret.push(part);\n      }\n    }\n    return ret.join(\"\");\n  }\n}\n\n//# sourceURL=webpack://@rangerrick/moment-javaformat/./src/formats/DateTimeFormatter.ts?");

/***/ }),

/***/ "./src/formats/SimpleDateFormat.ts":
/*!*****************************************!*\
  !*** ./src/formats/SimpleDateFormat.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SimpleDateFormat)\n/* harmony export */ });\n/* harmony import */ var _Formatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Formatter */ \"./src/Formatter.ts\");\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n//import { Moment } from 'moment-timezone';\n\n\nconst matchReserved = /[A-Za-z]/;\nconst eraFormatter = moment => {\n  return moment.year() > 0 ? \"AD\" : \"BC\";\n};\nconst guessZoneInfo = moment => {\n  let abbr = moment.zoneAbbr();\n  const name = moment.zoneName();\n  if (moment.tz) {\n    if (!name || name === \"\") {\n      // missing the zone name, probably can't find things right\n      return null;\n    }\n    if (abbr === \"UTC\" && moment.utcOffset() !== 0) {\n      // we only know the offset\n      return null;\n    }\n\n    // return name;\n    return {\n      abbr: abbr,\n      name: name,\n      description: (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.getDescriptionForAbbreviation)(abbr)\n    };\n  }\n  abbr = (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.getZoneForDateTime)(moment);\n  if (abbr) {\n    const match = (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.getDescriptionForAbbreviation)(abbr);\n    if (match) {\n      return {\n        abbr: abbr,\n        name: name,\n        description: match\n      };\n    }\n  }\n  return null;\n};\nconst javaToMoment = {\n  // Era designator\n  G: eraFormatter,\n  GG: eraFormatter,\n  GGG: eraFormatter,\n  GGGG: eraFormatter,\n  GGGGG: eraFormatter,\n  GGGGGG: eraFormatter,\n  // Year\n  y: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"Y\"));\n  },\n  yy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YY\"));\n  },\n  yyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\")), 3);\n  },\n  yyyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\"));\n  },\n  yyyyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\")), 5);\n  },\n  yyyyyy: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(moment.format(\"YYYY\")), 6);\n  },\n  // Week year\n  Y: \"gggg\",\n  YY: \"gg\",\n  YYY: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"gggg\"), 3);\n  },\n  YYYY: \"gggg\",\n  YYYYY: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"gggg\"), 5);\n  },\n  YYYYYY: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"gggg\"), 6);\n  },\n  // Month in year\n  M: \"M\",\n  MM: \"MM\",\n  MMM: \"MMM\",\n  MMMM: \"MMMM\",\n  MMMMM: \"MMMM\",\n  MMMMMM: \"MMMM\",\n  // Week in year\n  w: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"w\"), 1);\n  },\n  ww: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"w\"), 2);\n  },\n  www: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"w\"), 3);\n  },\n  wwww: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"w\"), 4);\n  },\n  wwwww: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"w\"), 5);\n  },\n  wwwwww: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"w\"), 6);\n  },\n  // Week in month (W) not supported\n  W: null,\n  WW: null,\n  WWW: null,\n  WWWW: null,\n  // Day in year\n  D: \"DDD\",\n  DD: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"DDD\"), 2);\n  },\n  DDD: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"DDD\"), 3);\n  },\n  DDDD: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"DDD\"), 4);\n  },\n  DDDDD: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"DDD\"), 5);\n  },\n  DDDDDD: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"DDD\"), 6);\n  },\n  // Day in month\n  d: \"D\",\n  dd: \"DD\",\n  ddd: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"D\"), 3);\n  },\n  dddd: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"D\"), 4);\n  },\n  ddddd: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"D\"), 5);\n  },\n  dddddd: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"D\"), 6);\n  },\n  // Day of week in month (F) not supported\n  F: null,\n  FF: null,\n  FFF: null,\n  FFFF: null,\n  // Day name in week\n  E: \"ddd\",\n  EE: \"ddd\",\n  EEE: \"ddd\",\n  EEEE: \"dddd\",\n  EEEEE: \"dddd\",\n  EEEEEE: \"dddd\",\n  // Day number of week\n  u: \"E\",\n  uu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"E\"), 2);\n  },\n  uuu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"E\"), 3);\n  },\n  uuuu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"E\"), 4);\n  },\n  uuuuu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"E\"), 5);\n  },\n  uuuuuu: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"E\"), 6);\n  },\n  // Am/pm marker\n  a: \"A\",\n  aa: \"A\",\n  aaa: \"A\",\n  aaaa: \"A\",\n  aaaaa: \"A\",\n  aaaaaa: \"A\",\n  // Hour in day (0-23)\n  H: \"H\",\n  HH: \"HH\",\n  HHH: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"H\"), 3);\n  },\n  HHHH: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"H\"), 4);\n  },\n  HHHHH: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"H\"), 5);\n  },\n  HHHHHH: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"H\"), 6);\n  },\n  // Hour in day (1-24)\n  k: \"k\",\n  kk: \"kk\",\n  kkk: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"k\"), 3);\n  },\n  kkkk: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"k\"), 4);\n  },\n  kkkkk: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"k\"), 5);\n  },\n  kkkkkk: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"k\"), 6);\n  },\n  // Hour in am/pm (0-11)\n  // except java doesn't actually do this, it outputs the same as 'h'!  (sigh)\n  K: moment => {\n    const asNumber = parseInt(moment.format(\"h\"), 10);\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(asNumber % 12);\n  },\n  KK: moment => {\n    const asNumber = parseInt(moment.format(\"h\"), 10);\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(asNumber % 12), 2);\n  },\n  KKK: moment => {\n    const asNumber = parseInt(moment.format(\"h\"), 10);\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(asNumber % 12), 3);\n  },\n  KKKK: moment => {\n    const asNumber = parseInt(moment.format(\"h\"), 10);\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(asNumber % 12), 4);\n  },\n  KKKKK: moment => {\n    const asNumber = parseInt(moment.format(\"h\"), 10);\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(asNumber % 12), 5);\n  },\n  KKKKKK: moment => {\n    const asNumber = parseInt(moment.format(\"h\"), 10);\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)((0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.toAbsString)(asNumber % 12), 6);\n  },\n  // Hour in am/pm (1-12)\n  h: \"h\",\n  hh: \"hh\",\n  hhh: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"h\"), 3);\n  },\n  hhhh: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"h\"), 4);\n  },\n  hhhhh: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"h\"), 5);\n  },\n  hhhhhh: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"h\"), 6);\n  },\n  // Minute in hour\n  m: \"m\",\n  mm: \"mm\",\n  mmm: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"m\"), 3);\n  },\n  mmmm: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"m\"), 4);\n  },\n  mmmmm: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"m\"), 5);\n  },\n  mmmmmm: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"m\"), 6);\n  },\n  // Second in minute\n  s: \"s\",\n  ss: \"ss\",\n  sss: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"s\"), 3);\n  },\n  ssss: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"s\"), 4);\n  },\n  sssss: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"s\"), 5);\n  },\n  ssssss: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"s\"), 6);\n  },\n  // Millisecond\n  S: \"S\",\n  SS: \"SS\",\n  SSS: \"SSS\",\n  SSSS: \"SSSS\",\n  SSSSS: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"SSSS\"), 5);\n  },\n  SSSSSS: moment => {\n    return (0,_Formatter__WEBPACK_IMPORTED_MODULE_0__.zeroPad)(moment.format(\"SSSS\"), 6);\n  },\n  // Time zone (Pacific Standard Time; PST)\n  z: moment => {\n    const info = guessZoneInfo(moment);\n    if (info) {\n      return info.abbr;\n    }\n    return \"GMT\" + moment.format(\"Z\");\n  },\n  zz: moment => {\n    const info = guessZoneInfo(moment);\n    if (info) {\n      return info.abbr;\n    }\n    return \"GMT\" + moment.format(\"Z\");\n  },\n  zzz: moment => {\n    const info = guessZoneInfo(moment);\n    if (info) {\n      return info.abbr;\n    }\n    return \"GMT\" + moment.format(\"Z\");\n  },\n  zzzz: moment => {\n    const info = guessZoneInfo(moment);\n    if (info) {\n      return info.description;\n    }\n    return \"GMT\" + moment.format(\"Z\");\n  },\n  zzzzz: moment => {\n    const info = guessZoneInfo(moment);\n    if (info) {\n      return info.description;\n    }\n    return \"GMT\" + moment.format(\"Z\");\n  },\n  zzzzzz: moment => {\n    const info = guessZoneInfo(moment);\n    if (info) {\n      return info.description;\n    }\n    return \"GMT\" + moment.format(\"Z\");\n  },\n  // Time zone (-0800)\n  Z: \"ZZ\",\n  ZZ: \"ZZ\",\n  ZZZ: \"ZZ\",\n  ZZZZ: \"ZZ\",\n  ZZZZZ: \"ZZ\",\n  ZZZZZZ: \"ZZ\",\n  // Time zone (-08; -0800; -08:00)\n  X: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"Z\").substr(0, 3);\n  },\n  XX: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"ZZ\");\n  },\n  XXX: moment => {\n    if (moment.utcOffset() === 0) {\n      return \"Z\";\n    }\n    return moment.format(\"Z\");\n  }\n};\nclass SimpleDateFormat extends _Formatter__WEBPACK_IMPORTED_MODULE_0__.Formatter {\n  tokenize(pattern) {\n    const ret = [];\n    const length = pattern.length;\n    let inQuote = false;\n    let count = 0;\n    let lastTag = null;\n    let tmpBuffer = null;\n    const encode = (tag, length) => {\n      const translate = javaToMoment[tag];\n      if (translate === null) {\n        throw new Error(`'${tag.repeat(length)}' cannot be converted to a moment format token; token is not implemented`);\n      } else if (translate === undefined) {\n        throw new Error(`'${tag.repeat(length)}' cannot be converted to a moment format token; unknown token`);\n      }\n      ret.push(new _Formatter__WEBPACK_IMPORTED_MODULE_0__.Token(tag, length));\n    };\n    const append = value => {\n      if (ret[ret.length - 1] instanceof _Formatter__WEBPACK_IMPORTED_MODULE_0__.Token) {\n        ret.push(value);\n      } else {\n        ret[ret.length - 1] += value;\n      }\n    };\n    for (let i = 0; i < length; i++) {\n      let c = pattern.charAt(i);\n      if (c === \"'\") {\n        // '' is treated as a single quote regardless of being\n        // in a quoted section.\n        if (i + 1 < length) {\n          c = pattern.charAt(i + 1);\n          if (c === \"'\") {\n            i++;\n            if (count != 0) {\n              encode(lastTag, count);\n              lastTag = null;\n              count = 0;\n            }\n            if (inQuote) {\n              tmpBuffer += c;\n            } else {\n              append(c);\n            }\n            continue;\n          }\n        }\n        if (!inQuote) {\n          if (count !== 0) {\n            encode(lastTag, count);\n            lastTag = null;\n            count = 0;\n          }\n          tmpBuffer = \"\";\n          inQuote = true;\n        } else {\n          append(tmpBuffer);\n          inQuote = false;\n        }\n        continue;\n      }\n      if (inQuote) {\n        tmpBuffer += c;\n        continue;\n      }\n      if (!c.match(matchReserved)) {\n        if (count !== 0) {\n          encode(lastTag, count);\n          lastTag = null;\n          count = 0;\n        }\n        if (c.charCodeAt(0) < 128) {\n          // In most cases, c would be a delimiter, such as ':'.\n          append(c);\n        } else {\n          // Take any contiguous non-ASCII alphabet characters and\n          // put them in a single TAG_QUOTE_CHARS.\n          let j;\n          for (j = i + 1; j < length; j++) {\n            const d = pattern.charAt(j);\n            if (d === \"'\" || d.match(matchReserved)) {\n              break;\n            }\n          }\n          for (; i < j; i++) {\n            append(pattern.charAt(i));\n          }\n          i--;\n        }\n        continue;\n      }\n      const tag = javaToMoment[c];\n      if (tag === undefined) {\n        throw new Error(`Illegal pattern character '${c}'`);\n      }\n      if (lastTag === null || lastTag === c) {\n        lastTag = c;\n        count++;\n        continue;\n      }\n      encode(lastTag, count);\n      lastTag = c;\n      count = 1;\n    }\n    if (inQuote) {\n      throw new Error(\"Unterminated quote\");\n    }\n    if (count != 0) {\n      encode(lastTag, count);\n    }\n    return ret;\n  }\n\n  /**\n   * Convert a moment into a formatted date string, using the format tokens defined at: https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\n   *\n   * @param {Moment} moment - the moment to convert\n   * @param {string} formatString - the format string\n   */\n  format(moment, formatString) {\n    const parts = this.tokenize(formatString);\n    const ret = [];\n    for (const part of parts) {\n      if (part instanceof _Formatter__WEBPACK_IMPORTED_MODULE_0__.Token) {\n        const partString = part.toString();\n        const translation = javaToMoment[partString];\n        if (translation === undefined) {\n          throw new Error(`'${partString}' cannot be converted to a moment format token; unknown token`);\n        } else {\n          if (typeof translation === \"function\") {\n            ret.push(translation(moment, partString));\n          } else {\n            ret.push(moment.format(translation));\n          }\n        }\n      } else {\n        ret.push(part);\n      }\n    }\n    return ret.join(\"\");\n  }\n}\n\n//# sourceURL=webpack://@rangerrick/moment-javaformat/./src/formats/SimpleDateFormat.ts?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTimeFormatter: () => (/* reexport safe */ _formats_DateTimeFormatter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   SimpleDateFormat: () => (/* reexport safe */ _formats_SimpleDateFormat__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   register: () => (/* binding */ register)\n/* harmony export */ });\n/* harmony import */ var _formats_SimpleDateFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats/SimpleDateFormat */ \"./src/formats/SimpleDateFormat.ts\");\n/* harmony import */ var _formats_DateTimeFormatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formats/DateTimeFormatter */ \"./src/formats/DateTimeFormatter.ts\");\n/* eslint-disable @typescript-eslint/no-var-requires */\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n\n\nconst register = function (moment) {\n  let fatal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (moment && moment.fn.zoneAbbr) {\n    console.log(\"register:\", moment, fatal);\n    if (moment.tz) {\n      console.log(\"Moment.js with timezone support detected; attaching Java format methods.\");\n    } else {\n      console.warn(\"Moment.js detected, but timezone support is missing.  Some Java formatting features may not work as expected.\");\n    }\n    const sdf = new _formats_SimpleDateFormat__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    const dtf = new _formats_DateTimeFormatter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    moment.fn.formatJavaSDF = function (formatString) {\n      return sdf.format(this, formatString);\n    };\n    moment.fn.formatJavaDTF = function (formatString) {\n      return dtf.format(this, formatString);\n    };\n    return moment;\n  } else {\n    console.error(\"Unable to attach Java format methods.  Moment.js object was invalid.\");\n    if (fatal) {\n      throw new Error(\"Moment.js object was invalid.\");\n    }\n  }\n  return undefined;\n};\n\n/*\n  Attempt to register with global Moment.js object if it's found,\n  preferring `moment-timezone` over `moment`.\n*/\n\nif (typeof window !== \"undefined\" && window?.moment) {\n  register(window.moment, false);\n} else if (typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g?.moment) {\n  register(__webpack_require__.g.moment, false);\n} else if (typeof window !== \"undefined\" && window) {\n  try {\n    const moment = __webpack_require__(/*! moment-timezone */ \"moment-timezone\");\n    window.moment = register(moment, false);\n  } catch (err) {\n    console.warn(\"Failed to load moment-timezone. Attempting fallback to moment.\");\n    try {\n      const moment = __webpack_require__(/*! moment */ \"moment\");\n      window.moment = register(moment, false);\n    } catch (subErr) {\n      console.warn(\"Failed to load moment.  User will have to manually register.\");\n    }\n  }\n}\nlet m = undefined;\nif (typeof window !== \"undefined\") {\n  m = window?.moment;\n}\nif (typeof m === \"undefined\" && typeof __webpack_require__.g !== \"undefined\") {\n  m = __webpack_require__.g?.moment;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (m);\n\n\n//# sourceURL=webpack://@rangerrick/moment-javaformat/./src/index.js?");

/***/ }),

/***/ "moment":
/*!*************************!*\
  !*** external "moment" ***!
  \*************************/
/***/ ((module) => {

if(typeof __WEBPACK_EXTERNAL_MODULE_moment__ === 'undefined') { var e = new Error("Cannot find module 'moment'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_moment__;

/***/ }),

/***/ "moment-timezone":
/*!**********************************!*\
  !*** external "moment-timezone" ***!
  \**********************************/
/***/ ((module) => {

if(typeof __WEBPACK_EXTERNAL_MODULE_moment_timezone__ === 'undefined') { var e = new Error("Cannot find module 'moment-timezone'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_moment_timezone__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});