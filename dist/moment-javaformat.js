(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((function webpackLoadOptionalExternalModule() { try { return require("moment"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("moment-timezone"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define(["moment", "moment-timezone"], factory);
	else {
		var a = typeof exports === 'object' ? factory((function webpackLoadOptionalExternalModule() { try { return require("moment"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("moment-timezone"); } catch(e) {} }())) : factory(root["moment"], root["moment-timezone"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE_moment__, __WEBPACK_EXTERNAL_MODULE_moment_timezone__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Formatter.ts":
/*!**************************!*\
  !*** ./src/Formatter.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Formatter = exports.Token = exports.zeroPad = exports.toAbsString = exports.getZoneForDateTime = exports.getDescriptionForAbbreviation = exports.findAbbreviationForOffset = void 0;\n\nvar _abbreviations = __webpack_require__(/*! ./abbreviations */ \"./src/abbreviations.ts\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar offsetMappings = {};\n\nvar findAbbreviationForOffset = function findAbbreviationForOffset(offset) {\n  if (!moment.tz) {\n    return null;\n  }\n\n  var tz = moment.tz.guess();\n  var short = tz ? moment.tz(tz).format('z') : null; //  console.log('guessed=', short);\n\n  var matches = _abbreviations.offsets[String(offset)];\n\n  if (matches) {\n    // check if the current browser zone matches our offset mapping\n    // and if so, shortcut to that abbreviation\n    if (matches.indexOf(short) >= 0) {\n      return short;\n    } else {\n      // otherwise, return the first/primary abbreviation in the offset mapping\n      return matches[0];\n    }\n  }\n\n  return null;\n};\n\nexports.findAbbreviationForOffset = findAbbreviationForOffset;\n\nvar getDescriptionForAbbreviation = function getDescriptionForAbbreviation(abbr) {\n  if (_abbreviations.abbreviations[abbr]) {\n    return _abbreviations.abbreviations[abbr];\n  }\n\n  return null;\n};\n\nexports.getDescriptionForAbbreviation = getDescriptionForAbbreviation;\n\nvar getZoneForDateTime = function getZoneForDateTime(dateTime) {\n  var dt = moment(dateTime);\n  var offset = dt.utcOffset();\n\n  if (!offsetMappings[offset]) {\n    var shortcut = findAbbreviationForOffset(offset);\n\n    if (shortcut) {\n      offsetMappings[offset] = shortcut;\n    } else {\n      console.warn('- unhandled offset: ' + offset);\n    }\n  }\n\n  return offsetMappings[offset] || null;\n};\n\nexports.getZoneForDateTime = getZoneForDateTime;\n\nvar toAbsString = function toAbsString(value) {\n  if (Number.isInteger(value)) {\n    return String(Math.abs(value));\n  }\n\n  return value.replace(/^-/, '');\n};\n\nexports.toAbsString = toAbsString;\n\nvar zeroPad = function zeroPad(input, length) {\n  var abs = toAbsString(input); // never truncate, just return if it's bigger\n\n  if (abs.length >= length) {\n    return String(input);\n  }\n\n  return (abs !== input ? '-' : '') + ('0'.repeat(length) + abs).substr(0 - length);\n};\n\nexports.zeroPad = zeroPad;\n\nvar Token =\n/*#__PURE__*/\nfunction () {\n  function Token(value, count) {\n    _classCallCheck(this, Token);\n\n    _defineProperty(this, \"token\", void 0);\n\n    _defineProperty(this, \"count\", 0);\n\n    if (value.length != 1) {\n      throw new Error('You must provide a single character when creating a token!');\n    }\n\n    this.token = value;\n    this.count = count === undefined ? 1 : count;\n  }\n\n  _createClass(Token, [{\n    key: \"increment\",\n    value: function increment() {\n      this.count++;\n      return this.count;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(token) {\n      return this.token === token.token && this.count === token.count;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.token.repeat(this.count);\n    }\n  }]);\n\n  return Token;\n}();\n\nexports.Token = Token;\n\nvar Formatter = function Formatter() {\n  _classCallCheck(this, Formatter);\n};\n\nexports.Formatter = Formatter;\n\n//# sourceURL=webpack:///./src/Formatter.ts?");

/***/ }),

/***/ "./src/abbreviations.ts":
/*!******************************!*\
  !*** ./src/abbreviations.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.abbreviations = exports.offsets = void 0;\n\n/*\n// Java 8 mappings:\nEST - -05:00\nHST - -10:00\nMST - -07:00\nACT - Australia/Darwin\nAET - Australia/Sydney\nAGT - America/Argentina/Buenos_Aires\nART - Africa/Cairo\nAST - America/Anchorage\nBET - America/Sao_Paulo\nBST - Asia/Dhaka\nCAT - Africa/Harare\nCNT - America/St_Johns\nCST - America/Chicago\nCTT - Asia/Shanghai\nEAT - Africa/Addis_Ababa\nECT - Europe/Paris\nIET - America/Indiana/Indianapolis\nIST - Asia/Kolkata\nJST - Asia/Tokyo\nMIT - Pacific/Apia\nNET - Asia/Yerevan\nNST - Pacific/Auckland\nPLT - Asia/Karachi\nPNT - America/Phoenix\nPRT - America/Puerto_Rico\nPST - America/Los_Angeles\nSST - Pacific/Guadalcanal\nVST - Asia/Ho_Chi_Minh\n*/\nvar offsets = {\n  '-720': ['AoE', 'Y'],\n  // -12\n  '-660': ['NUT', 'SST', 'X'],\n  // -11\n  '-600': ['HST', 'CKT', 'TAHT', 'W'],\n  // -10\n  '-570': ['MART'],\n  // -9:30\n  '-540': ['AKST', 'HDT', 'GAMT', 'V'],\n  // -9\n  '-480': ['PST', 'AKDT', 'U', 'PT'],\n  // -8\n  '-420': ['MST', 'PDT', 'T', 'MT', 'PT'],\n  // -7\n  '-360': ['CST', 'MDT', 'EAST', 'GALT', 'S', 'CT', 'MT'],\n  // -6\n  '-300': ['EST', 'CDT', 'ACT', 'CIST', 'COT', 'CST', 'EASST', 'ECT', 'PET', 'R', 'ET', 'CT'],\n  // -5\n  '-240': ['EDT', 'AST', 'AMT', 'BOT', 'CIDST', 'CLT', 'FKT', 'GYT', 'VET', 'Q', 'AT', 'ET'],\n  // -4\n  '-210': ['NST'],\n  // -3:30\n  '-180': ['UYT', 'ADT', 'AMST', 'ART', 'BRT', 'CLST', 'FKST', 'GFT', 'PMST', 'ROTT', 'SRT', 'UYT', 'WARST', 'WGT', 'P', 'AT'],\n  // -3\n  '-150': ['NDT'],\n  // -2:30\n  '-120': ['GST', 'BRST', 'FNT', 'GST', 'PMDT', 'UYST', 'WGST', 'O'],\n  // -2\n  '-60': ['CVT', 'AZOT', 'CVT', 'EGT', 'N'],\n  // -1\n  '0': ['UTC', 'GMT', 'AZOST', 'EGST', 'WET', 'Z', 'WT'],\n  // +/-0\n  '60': ['CET', 'BST', 'WAT', 'WEST', 'WST', 'A'],\n  // +1\n  '120': ['CAT', 'CEST', 'EET', 'SAST', 'WAST', 'B'],\n  // +2\n  '180': ['EAT', 'EEST', 'FET', 'MSK', 'SYOT', 'TRT', 'C'],\n  // +3\n  '210': ['IRST'],\n  // +3:30\n  '240': ['GET', 'AZT', 'KUYT', 'MSD', 'MUT', 'RET', 'SAMT', 'SCT', 'D'],\n  // +4\n  '270': ['AFT', 'IRDT'],\n  // +4:30\n  '300': ['UZT', 'AQTT', 'AZST', 'MAWT', 'MVT', 'ORAT', 'PKT', 'TFT', 'TJT', 'TMT', 'YEKT', 'E'],\n  // +5\n  '330': ['IST'],\n  // +5:30\n  '345': ['NPT'],\n  // +5:45\n  '360': ['BTT', 'ALMT', 'BTT', 'IOT', 'KGT', 'OMST', 'QYZT', 'VOST', 'YEKST', 'F'],\n  // +6\n  '390': ['MMT', 'CCT'],\n  // +6:30\n  '420': ['ICT', 'CXT', 'DAVT', 'HOVT', 'KRAT', 'NOVST', 'NOVT', 'OMSST', 'WIB', 'G'],\n  // +7\n  '480': ['HKT', 'AWST', 'BNT', 'CAST', 'CHOT', 'HOVST', 'IRKT', 'KRAST', 'MYT', 'PHT', 'SGT', 'ULAT', 'WITA', 'H'],\n  // +8\n  '510': ['PYT'],\n  // +8:30\n  '525': ['ACWST'],\n  // +8:45\n  '540': ['JST', 'AWDT', 'CHOST', 'IRKST', 'KST', 'PWT', 'TLT', 'ULAST', 'WIT', 'YAKT', 'I'],\n  // +9\n  '570': ['ACST', 'ACT'],\n  // +9:30\n  '600': ['PGT', 'AEST', 'CHUT', 'ChST', 'DDUT', 'VLAT', 'YAKST', 'YAPT', 'K', 'AET'],\n  // +10\n  '630': ['ACDT', 'LHST', 'ACT'],\n  // +10:30\n  '660': ['VUT', 'AEDT', 'KOST', 'LHDT', 'MAGT', 'NCT', 'NFT', 'PONT', 'SAKT', 'SBT', 'SRET', 'VLAST', 'L', 'AET'],\n  // +11\n  '720': ['FJT', 'ANAST', 'ANAT', 'GILT', 'MAGST', 'MHT', 'NFDT', 'NRT', 'NZST', 'PETST', 'PETT', 'TVT', 'WAKT', 'WFT', 'M'],\n  // +12\n  '765': ['CHAST'],\n  // +12:45\n  '780': ['TOT', 'FJST', 'NZDT', 'PHOT', 'TKT', 'TOT'],\n  // +13\n  '825': ['CHADT'],\n  // +13:45\n  '840': ['LINT', 'TOST', 'WST'] // +14\n\n};\nexports.offsets = offsets;\nvar abbreviations = {\n  A: 'Alpha Time Zone',\n  ACDT: 'Australian Central Daylight Time',\n  ACST: 'Australian Central Standard Time',\n  //  ACT: 'Acre Time',\n  ACT: 'Australian Central Time',\n  ACWST: 'Australian Central Western Standard Time',\n  //  ADT: 'Arabia Daylight Time',\n  ADT: 'Atlantic Daylight Time',\n  ADST: 'Atlantic Daylight Saving Time',\n  AEDT: 'Australian Eastern Daylight Time',\n  AEST: 'Australian Eastern Standard Time',\n  AET: 'Australian Eastern Time',\n  AFT: 'Afghanistan Time',\n  AKDT: 'Alaska Daylight Time',\n  AKST: 'Alaska Standard Time',\n  ALMT: 'Alma-Ata Time',\n  AMDT: 'Armenia Daylight Time',\n  AMST: 'Amazon Summer Time',\n  //  AMST: 'Armenia Summer Time',\n  AMT: 'Amazon Time',\n  //  AMT: 'Armenia Time',\n  ANAST: 'Anadyr Summer Time',\n  ANAT: 'Anadyr Time',\n  AQTT: 'Aqtobe Time',\n  ART: 'Argentina Time',\n  //  AST: 'Arabia Standard Time',\n  AST: 'Atlantic Standard Time',\n  AT: 'Atlantic Time',\n  AWDT: 'Australian Western Daylight Time',\n  AWST: 'Australian Western Standard Time',\n  AZODT: 'Azores Daylight Time',\n  AZOST: 'Azores Summer Time',\n  AZOT: 'Azores Time',\n  AZST: 'Azerbaijan Summer Time',\n  AZT: 'Azerbaijan Time',\n  AoE: 'Anywhere on Earth',\n  B: 'Bravo Time Zone',\n  BDST: 'British Daylight Saving Time',\n  //  BDT: 'British Daylight Time',\n  BDT: 'Brunei Time',\n  BNT: 'Brunei Darussalam Time',\n  BOT: 'Bolivia Time',\n  BRST: 'Brasília Summer Time',\n  BRT: 'Brasília Time',\n  //  BST: 'Bangladesh Standard Time',\n  //  BST: 'Bougainville Standard Time',\n  BST: 'British Summer Time',\n  BT: 'Brazil Time',\n  BTT: 'Bhutan Time',\n  C: 'Charlie Time Zone',\n  CAST: 'Casey Time',\n  CAT: 'Central Africa Time',\n  CCT: 'Cocos Islands Time',\n  CDT: 'Central Daylight Time',\n  //  CDT: 'Cuba Daylight Time',\n  CDST: 'Central Daylight Savings Time',\n  CEDT: 'Central European Daylight Time',\n  CEST: 'Central European Summer Time',\n  CET: 'Central European Time',\n  CHADT: 'Chatham Island Daylight Time',\n  CHAST: 'Chatham Island Standard Time',\n  CHODT: 'Choibalsan Daylight Time',\n  CHODST: 'Choibalsan Daylight Saving Time',\n  CHOST: 'Choibalsan Summer Time',\n  CHOT: 'Choibalsan Time',\n  CHUT: 'Chuuk Time',\n  CIDST: 'Cayman Islands Daylight Saving Time',\n  CIST: 'Cayman Islands Standard Time',\n  CIT: 'Cayman Islands Time',\n  CKT: 'Cook Island Time',\n  CLDT: 'Chile Daylight Time',\n  CLST: 'Chile Summer Time',\n  CLT: 'Chile Standard Time',\n  COT: 'Colombia Time',\n  CST: 'Central Standard Time',\n  //  CST: 'China Standard Time',\n  //  CST: 'Cuba Standard Time',\n  CT: 'Central Time',\n  CVT: 'Cape Verde Time',\n  CXT: 'Christmas Island Time',\n  ChST: 'Chamorro Standard Time',\n  D: 'Delta Time Zone',\n  DAVT: 'Davis Time',\n  DDUT: \"Dumont-d'Urville Time\",\n  E: 'Echo Time Zone',\n  EADT: 'Easter Island Daylight Time',\n  EASST: 'Easter Island Summer Time',\n  EAST: 'Easter Island Standard Time',\n  EAT: 'Eastern Africa Time',\n  ECST: 'European Central Summer Time',\n  ECT: 'Ecuador Time',\n  EDT: 'Eastern Daylight Time',\n  EDST: 'Eastern Daylight Saving Time',\n  EEDT: 'Eastern European Daylight Time',\n  EEST: 'Eastern European Summer Time',\n  EET: 'Eastern European Time',\n  EFATE: 'Efate Time',\n  EGST: 'Eastern Greenland Summer Time',\n  EGT: 'East Greenland Time',\n  EST: 'Eastern Standard Time',\n  ET: 'Eastern Time',\n  F: 'Foxtrot Time Zone',\n  FET: 'Further-Eastern European Time',\n  FJDT: 'Fiji Daylight Time',\n  FJST: 'Fiji Summer Time',\n  FJT: 'Fiji Time',\n  FKDT: 'Falkland Island Daylight Time',\n  FKST: 'Falkland Islands Summer Time',\n  FKT: 'Falkland Island Time',\n  FNT: 'Fernando de Noronha Time',\n  G: 'Golf Time Zone',\n  GALT: 'Galapagos Time',\n  GAMT: 'Gambier Time',\n  GET: 'Georgia Standard Time',\n  GFT: 'French Guiana Time',\n  GILT: 'Gilbert Island Time',\n  GMT: 'Greenwich Mean Time',\n  //  GST: 'Gulf Standard Time',\n  GST: 'South Georgia Time',\n  GT: 'Greenwich Time',\n  GYT: 'Guyana Time',\n  H: 'Hotel Time Zone',\n  HAA: \"Heure Avancée de l'Atlantique\",\n  HAC: \"Heure Avancée du Centre\",\n  HADT: 'Hawaii Daylight Time',\n  HAE: \"Heure Avancée de l'Est\",\n  HAP: 'Heure Avancée du Pacifique',\n  HAST: 'Hawaii-Aleutian Standard Time',\n  HAR: \"Heure Avancée des Rocheuses\",\n  HAT: \"Heure Avancée de Terre-Neuve\",\n  HDT: 'Hawaii-Aleutian Daylight Time',\n  HLV: 'Hora Legal de Venezuela',\n  HNA: \"Heure Normale de l'Atlantique\",\n  HNC: \"Heure Normale du Centre\",\n  HNE: \"Heure Normale de l'Est\",\n  HNP: 'Heure Normale du Pacifique',\n  HNR: \"Heure Normale des Rocheuses\",\n  HNT: 'Heure Normale de Terre-Neuve',\n  HKT: 'Hong Kong Time',\n  HOVDT: 'Hovd Daylight Time',\n  HOVDST: 'Hovd Daylight Saving Time',\n  HOVST: 'Hovd Summer Time',\n  HOVT: 'Hovd Time',\n  HST: 'Hawaii Standard Time',\n  I: 'India Time Zone',\n  ICT: 'Indochina Time',\n  IDT: 'Israel Daylight Time',\n  IOT: 'Indian Chagos Time',\n  IRDT: 'Iran Daylight Time',\n  IRKST: 'Irkutsk Summer Time',\n  IRKT: 'Irkutsk Time',\n  IRST: 'Iran Standard Time',\n  IST: 'India Standard Time',\n  //  IST: 'Irish Standard Time',\n  //  IST: 'Israel Standard Time',\n  JST: 'Japan Standard Time',\n  K: 'Kilo Time Zone',\n  KGT: 'Kyrgyzstan Time',\n  KIT: 'Kerguelen (Islands) Time',\n  KOST: 'Kosrae Time',\n  KRAST: 'Krasnoyarsk Summer Time',\n  KRAT: 'Krasnoyarsk Time',\n  KST: 'Korea Standard Time',\n  KT: 'Korea Time',\n  KUYT: 'Kuybyshev Time',\n  L: 'Lima Time Zone',\n  LHDT: 'Lord Howe Daylight Time',\n  LHST: 'Lord Howe Standard Time',\n  LINT: 'Line Islands Time',\n  M: 'Mike Time Zone',\n  MAGST: 'Magadan Summer Time',\n  MAGT: 'Magadan Time',\n  MART: 'Marquesas Time',\n  MAWT: 'Mawson Time',\n  MCK: 'Moscow Time',\n  MDST: 'Mountain Daylight Saving Time',\n  MDT: 'Mountain Daylight Time',\n  MESZ: 'Mitteleuropäische Sommerzeit',\n  MEZ: 'Mitteleuropäische Zeit',\n  MHT: 'Marshall Islands Time',\n  MMT: 'Myanmar Time',\n  MST: 'Mountain Standard Time',\n  MSK: 'Moscow Standard Time',\n  MT: 'Mountain Time',\n  MUT: 'Mauritius Time',\n  MVT: 'Maldives Time',\n  MYT: 'Malaysia Time',\n  N: 'November Time Zone',\n  NACDT: 'North American Central Daylight Time',\n  NACST: 'North American Central Standard Time',\n  NAEDT: 'North American Eastern Daylight Time',\n  NAEST: 'North American Eastern Standard Time',\n  NAMDT: 'North American Mountain Daylight Time',\n  NAMST: 'North American Mountain Standard Time',\n  NAPDT: 'North American Pacific Daylight Time',\n  NAPST: 'North American Pacific Standard Time',\n  NCT: 'New Caledonia Time',\n  NDT: 'Newfoundland Daylight Time',\n  NFDT: 'Norfolk Daylight Time',\n  NFT: 'Norfolk Time',\n  NOVST: 'Novosibirsk Summer Time',\n  NOVT: 'Novosibirsk Time',\n  NPT: 'Nepal Time',\n  NRT: 'Nauru Time',\n  NST: 'Newfoundland Standard Time',\n  NUT: 'Niue Time',\n  NZDT: 'New Zealand Daylight Time',\n  NZST: 'New Zealand Standard Time',\n  O: 'Oscar Time Zone',\n  OESZ: 'Osteuropäische Sommerzeit',\n  OEZ: 'Osteuropäische Zeit',\n  OMSST: 'Omsk Summer Time',\n  OMST: 'Omsk Standard Time',\n  ORAT: 'Oral Time',\n  P: 'Papa Time Zone',\n  PDT: 'Pacific Daylight Time',\n  PDST: 'Pacific Daylight Saving Time',\n  PET: 'Peru Time',\n  PETST: 'Kamchatka Summer Time',\n  PETT: 'Kamchatka Time',\n  PGT: 'Papua New Guinea Time',\n  PHOT: 'Phoenix Island Time',\n  PHT: 'Philippine Time',\n  PKT: 'Pakistan Standard Time',\n  PMDT: 'Pierre & Miquelon Daylight Time',\n  PMST: 'Pierre & Miquelon Standard Time',\n  PONT: 'Pohnpei Standard Time',\n  PST: 'Pacific Standard Time',\n  //  PST: 'Pitcairn Standard Time',\n  PT: 'Pacific Time',\n  PWT: 'Palau Time',\n  //  PYST: 'Paraguay Summer Time',\n  PYST: 'Pyongyang Standard Time',\n  //  PYT: 'Paraguay Time',\n  PYT: 'Pyongyang Time',\n  Q: 'Quebec Time Zone',\n  QYZT: 'Qyzylorda Time',\n  R: 'Romeo Time Zone',\n  RET: 'Reunion Time',\n  ROTT: 'Rothera Time',\n  S: 'Sierra Time Zone',\n  SAKT: 'Sakhalin Time',\n  SAMT: 'Samara Time',\n  SAMST: 'Samara Summer Time',\n  SAST: 'South Africa Standard Time',\n  SBT: 'Solomon Islands Time',\n  SCT: 'Seychelles Time',\n  SGT: 'Singapore Time',\n  SRET: 'Srednekolymsk Time',\n  SRT: 'Suriname Time',\n  SST: 'Samoa Standard Time',\n  SYOT: 'Syowa Time',\n  T: 'Tango Time Zone',\n  TAHT: 'Tahiti Time',\n  TFT: 'French Southern and Antarctic Time',\n  TJT: 'Tajikistan Time',\n  TKT: 'Tokelau Time',\n  TLT: 'East Timor Time',\n  TMT: 'Turkmenistan Time',\n  TOST: 'Tonga Summer Time',\n  TOT: 'Tonga Time',\n  TRT: 'Turkey Time',\n  tVT: 'Tuvalu Time',\n  U: 'Uniform Time Zone',\n  ULAST: 'Ulaanbaatar Summer Time',\n  ULAT: 'Ulaanbaatar Time',\n  UTC: 'Coordinated Universal Time',\n  UYST: 'Uruguay Summer Time',\n  UYT: 'Uruguay Time',\n  UZT: 'Uzbekistan Time',\n  V: 'Victor Time Zone',\n  VET: 'Venezuelan Standard Time',\n  VLAST: 'Vladivostok Summer Time',\n  VLAT: 'Vladivostok Time',\n  VOST: 'Vostok Time',\n  VUT: 'Vanuatu Time',\n  W: 'Whiskey Time Zone',\n  WAKT: 'Wake Time',\n  WARST: 'Western Argentine Summer Time',\n  WAST: 'West Africa Summer Time',\n  //  WAT: 'Western Australia Time',\n  WAT: 'West Africa Time',\n  //  WAT: 'Western Australia Time',\n  WDT: 'Western Daylight Time',\n  WEDT: 'Western European Daylight Time',\n  WEST: 'Western European Summer Time',\n  WESZ: 'Westeuropäische Sommerzeit',\n  WET: 'Western European Time',\n  WEZ: 'Westeuropäische Zeit',\n  WFT: 'Wallis and Futuna Time',\n  WGST: 'Western Greenland Summer Time',\n  WGT: 'West Greenland Time',\n  WIB: 'Western Indonesian Time',\n  WIT: 'Eastern Indonesian Time',\n  WITA: 'Central Indonesian Time',\n  WST: 'Western Standard Time',\n  //  WST: 'West Samoa Time',\n  //  WST: 'Western Summer Time',\n  WT: 'Western Sahara Standard Time',\n  X: 'X-ray Time Zone',\n  Y: 'Yankee Time Zone',\n  YAKST: 'Yakutsk Summer Time',\n  YAKT: 'Yakutsk Time',\n  YAPT: 'Yap Time',\n  YEKST: 'Yekaterinburg Summer Time',\n  YEKT: 'Yekaterinburg Time',\n  Z: 'Zulu Time Zone'\n};\nexports.abbreviations = abbreviations;\nvar _default = abbreviations;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/abbreviations.ts?");

/***/ }),

/***/ "./src/formats/DateTimeFormatter.ts":
/*!******************************************!*\
  !*** ./src/formats/DateTimeFormatter.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.PaddedToken = void 0;\n\nvar _Formatter2 = __webpack_require__(/*! ../Formatter */ \"./src/Formatter.ts\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar endZeroes = /:?00$/;\nvar matchReserved = /[A-Za-z]/;\n\nvar adConverter = function adConverter(moment) {\n  return moment.year() > 0 ? 'AD' : 'BC';\n};\n\nvar findAbbreviation = function findAbbreviation(moment) {\n  var defaultAbbr = moment.zoneAbbr();\n\n  if (defaultAbbr === 'UTC' && moment.utcOffset() != 0) {\n    return null;\n  }\n\n  return defaultAbbr;\n};\n\nvar javaToMoment = {\n  // era\n  G: adConverter,\n  GG: adConverter,\n  GGG: adConverter,\n  GGGG: function GGGG(moment) {\n    return moment.year() > 0 ? 'Anno Domini' : 'Before Christ';\n  },\n  // year\n  u: function u(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('YYYY'), 1);\n  },\n  uu: function uu(moment) {\n    return (0, _Formatter2.zeroPad)((0, _Formatter2.toAbsString)(moment.format('YY')), 2);\n  },\n  uuu: function uuu(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('YYYY'), 3);\n  },\n  uuuu: 'YYYY',\n  // year-of-era\n  y: function y(moment) {\n    return (0, _Formatter2.toAbsString)(moment.format('Y'));\n  },\n  yy: function yy(moment) {\n    return (0, _Formatter2.toAbsString)(moment.format('YY'));\n  },\n  yyy: function yyy(moment) {\n    return (0, _Formatter2.zeroPad)((0, _Formatter2.toAbsString)(moment.format('YYYY')), 3);\n  },\n  yyyy: function yyyy(moment) {\n    return (0, _Formatter2.toAbsString)(moment.format('YYYY'));\n  },\n  // day-of-year\n  D: 'DDD',\n  DD: function DD(moment) {\n    var ret = moment.format('DDD');\n\n    if (ret.length > 2) {\n      throw new Error('Field DayOfYear cannot be printed as the value ' + ret + ' exceeds the maximum print width of 2');\n    }\n\n    return (0, _Formatter2.zeroPad)(ret, 2);\n  },\n  DDD: 'DDDD',\n  // DDDD throws an error in Java DateTimeFormatter\n  // month-of-year\n  M: 'M',\n  MM: 'MM',\n  MMM: 'MMM',\n  MMMM: 'MMMM',\n  // month-of-year (numeric)\n  L: 'M',\n  LL: 'MM',\n  LLL: 'M',\n  LLLL: 'M',\n  // day-of-month\n  d: 'D',\n  dd: 'DD',\n  // quarter-of-year\n  Q: 'Q',\n  QQ: function QQ(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('Q'), 2);\n  },\n  QQQ: function QQQ(moment) {\n    return 'Q' + moment.format('Q');\n  },\n  QQQQ: function QQQQ(moment) {\n    return moment.format('Qo') + ' quarter';\n  },\n  // quarter-of-year\n  q: 'Q',\n  qq: function qq(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('Q'), 2);\n  },\n  qqq: 'Q',\n  qqqq: 'Q',\n  // week-based-year\n  Y: function Y(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('gggg'), 1);\n  },\n  YY: 'gg',\n  YYY: function YYY(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('gggg'), 3);\n  },\n  YYYY: 'gggg',\n  // week-of-week-based-year\n  w: 'w',\n  ww: 'ww',\n  // week-of-month (W) not supported\n  W: null,\n  WW: null,\n  WWW: null,\n  WWWW: null,\n  // day-of-week\n  E: 'ddd',\n  EE: 'ddd',\n  EEE: 'ddd',\n  EEEE: 'dddd',\n  // localized day-of-week (e)\n  e: 'd',\n  ee: function ee(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('d'), 2);\n  },\n  eee: 'ddd',\n  eeee: 'dddd',\n  // localized day-of-week (c)\n  c: 'd',\n  ccc: 'ddd',\n  cccc: 'dddd',\n  // week of month (F) not supported\n  // am-pm-of-day\n  a: 'A',\n  // clock-hour-of-am-pm\n  h: 'h',\n  hh: 'hh',\n  // hour-of-am-pm\n  K: function K(moment) {\n    return (0, _Formatter2.toAbsString)(moment.hour() % 12);\n  },\n  KK: function KK(moment) {\n    var hour = (0, _Formatter2.toAbsString)(moment.hour() % 12);\n    return (0, _Formatter2.zeroPad)(hour, 2);\n  },\n  // clock-hour-of-am-pm\n  k: 'k',\n  kk: 'kk',\n  // hour-of-day\n  H: 'H',\n  HH: 'HH',\n  // minute-of-hour\n  m: 'm',\n  mm: 'mm',\n  // second-of-minute\n  s: 's',\n  ss: 'ss',\n  // fraction-of-second\n  S: 'S',\n  SS: 'SS',\n  SSS: 'SSS',\n  SSSS: 'SSSS',\n  // milli-of-day\n  A: function A(moment) {\n    return (0, _Formatter2.zeroPad)(moment.valueOf() - moment.clone().startOf('day').valueOf(), 1);\n  },\n  AA: function AA(moment) {\n    if (moment.isSame(moment.clone().startOf('day'))) {\n      // console.warn(moment.format() + ' is the same as ' + moment.clone().startOf('day').format());\n      return '00';\n    }\n\n    return null;\n  },\n  AAA: function AAA(moment) {\n    if (moment.isSame(moment.clone().startOf('day'))) {\n      return '000';\n    }\n\n    return null;\n  },\n  AAAA: function AAAA(moment) {\n    if (moment.isSame(moment.clone().startOf('day'))) {\n      return '0000';\n    }\n\n    return null;\n  },\n  // nano-of-second not supported\n  // nano-of-day not supported\n  // time-zone ID\n  VV: function VV(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    var tz = moment.tz();\n\n    if (tz && tz.length > 0) {\n      return tz;\n    }\n\n    return moment.format('Z');\n  },\n  // time-zone name\n  z: function z(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    var abbr = findAbbreviation(moment);\n\n    if (abbr) {\n      return abbr;\n    }\n\n    return moment.format('Z');\n  },\n  zz: function zz(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    var abbr = findAbbreviation(moment);\n\n    if (abbr) {\n      return abbr;\n    }\n\n    return moment.format('Z');\n  },\n  zzz: function zzz(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    var abbr = findAbbreviation(moment);\n\n    if (abbr) {\n      return abbr;\n    }\n\n    return moment.format('Z');\n  },\n  zzzz: function zzzz(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    var abbr = findAbbreviation(moment);\n\n    if (abbr) {\n      return (0, _Formatter2.getDescriptionForAbbreviation)(abbr);\n    }\n\n    return moment.format('Z');\n  },\n  // localized zone-offset\n  O: function O(moment) {\n    var offset = moment.utcOffset() / 60.0;\n\n    if (offset === 0) {\n      return 'GMT';\n    }\n\n    var ret = moment.format('Z').replace(endZeroes, '').replace(/^([+-])0/, '$1');\n    return 'GMT' + ret;\n  },\n  OOOO: function OOOO(moment) {\n    var offset = moment.utcOffset() / 60.0;\n\n    if (offset === 0) {\n      return 'GMT';\n    }\n\n    var ret = moment.format('Z');\n    return 'GMT' + ret;\n  },\n  // zone-offset 'Z' for zero\n  X: function X(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    var ret = moment.format('ZZ');\n\n    if (ret.match(endZeroes)) {\n      return ret.substr(0, 3);\n    }\n\n    return ret;\n  },\n  XX: function XX(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    return moment.format('ZZ');\n  },\n  XXX: function XXX(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    return moment.format('Z');\n  },\n  XXXX: function XXXX(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    return moment.format('ZZ');\n  },\n  // zone-offset\n  x: function x(moment) {\n    var ret = moment.format('ZZ');\n\n    if (ret.match(endZeroes)) {\n      return ret.substr(0, 3);\n    }\n\n    return ret;\n  },\n  xx: 'ZZ',\n  xxx: 'Z',\n  xxxx: 'ZZ',\n  // zone-offset\n  Z: function Z(moment) {\n    if (moment.utcOffset() === 0) {\n      return '+0000';\n    }\n\n    return moment.format('ZZ');\n  },\n  ZZ: function ZZ(moment) {\n    if (moment.utcOffset() === 0) {\n      return '+0000';\n    }\n\n    return moment.format('ZZ');\n  },\n  ZZZ: function ZZZ(moment) {\n    if (moment.utcOffset() === 0) {\n      return '+0000';\n    }\n\n    return moment.format('ZZ');\n  },\n  ZZZZ: function ZZZZ(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'GMT';\n    }\n\n    return 'GMT' + moment.format('Z');\n  }\n};\n\nvar PaddedToken =\n/*#__PURE__*/\nfunction (_Token) {\n  _inherits(PaddedToken, _Token);\n\n  function PaddedToken(padding, padChar, value, count) {\n    var _this;\n\n    _classCallCheck(this, PaddedToken);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PaddedToken).call(this, value, count));\n\n    _defineProperty(_assertThisInitialized(_this), \"padding\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"padChar\", void 0);\n\n    _this.padding = padding;\n    _this.padChar = padChar;\n    return _this;\n  }\n\n  _createClass(PaddedToken, [{\n    key: \"format\",\n    value: function format(input) {\n      if (input.length > this.padding) {\n        throw new Error(\"Cannot format padding as formatted string \\\"\".concat(input, \"\\\" exceeds pad width of \").concat(this.padding, \".\"));\n      }\n\n      var padded = this.padChar.repeat(this.padding) + input;\n      return padded.substr(0 - this.padding);\n    }\n  }]);\n\n  return PaddedToken;\n}(_Formatter2.Token);\n\nexports.PaddedToken = PaddedToken;\n\nvar DateTimeFormatter =\n/*#__PURE__*/\nfunction (_Formatter) {\n  _inherits(DateTimeFormatter, _Formatter);\n\n  function DateTimeFormatter() {\n    _classCallCheck(this, DateTimeFormatter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DateTimeFormatter).apply(this, arguments));\n  }\n\n  _createClass(DateTimeFormatter, [{\n    key: \"tokenize\",\n    value: function tokenize(formatString) {\n      var padNextWidth = 0;\n      var padNextChar = ' ';\n      var ret = [];\n\n      for (var pos = 0; pos < formatString.length; pos++) {\n        var cur = formatString.charAt(pos);\n\n        if (cur.match(matchReserved)) {\n          var start = pos++;\n\n          for (; pos < formatString.length && formatString.charAt(pos) === cur; pos++) {\n            ;\n          }\n\n          var count = pos - start; // padding parsed\n\n          if (cur === 'p') {\n            var pad = 0;\n\n            if (pos < formatString.length) {\n              cur = formatString.charAt(pos);\n\n              if (cur.match(matchReserved)) {\n                pad = count;\n                start = pos++;\n\n                for (; pos < formatString.length && formatString.charAt(pos) === cur; pos++) {\n                  ;\n                } // short loop\n\n\n                count = pos - start;\n              }\n            }\n\n            if (pad === 0) {\n              throw new Error(\"Pad letter 'p' must be followed by valid pad pattern: \" + formatString);\n            } // pad and continue parsing\n\n\n            padNextWidth = pad;\n            padNextChar = ' ';\n          } // main rules\n\n\n          var translate = javaToMoment[cur.repeat(count)];\n\n          if (translate === null) {\n            throw new Error(\"'\".concat(cur.repeat(count), \"' cannot be converted to a moment format token; token is not implemented\"));\n          } else if (translate === undefined) {\n            throw new Error(\"'\".concat(cur.repeat(count), \"' cannot be converted to a moment format token; unknown token\"));\n          } else {\n            if (padNextWidth > 0) {\n              ret.push(new PaddedToken(padNextWidth, padNextChar, cur, count));\n              padNextWidth = 0;\n              padNextChar = ' ';\n            } else {\n              ret.push(new _Formatter2.Token(cur, count));\n            }\n          }\n\n          pos--;\n        } else if (cur === '\\'') {\n          // parse literals\n          var _start = pos++;\n\n          for (; pos < formatString.length; pos++) {\n            if (formatString.charAt(pos) === '\\'') {\n              if (pos + 1 < formatString.length && formatString.charAt(pos + 1) === '\\'') {\n                pos++;\n              } else {\n                break; // end of literal\n              }\n            }\n          }\n\n          if (pos >= formatString.length) {\n            throw new Error(\"Pattern ends with an incomplete string literal: \".concat(formatString));\n          }\n\n          var str = formatString.substring(_start + 1, pos);\n\n          if (str.length == 0) {\n            ret.push('\\'');\n          } else {\n            ret.push(str.replace(\"''\", \"'\"));\n          }\n        } else if (cur === '[') {\n          throw new Error(\"Optional patterns are not supported: \".concat(cur));\n        } else if (cur === ']') {\n          throw new Error(\"Optional patterns are not supported: \".concat(cur));\n        } else if (cur === '{' || cur === '}' || cur === '#') {\n          throw new Error(\"Pattern includes reserved character: '\".concat(cur, \"'\"));\n        } else {\n          if (ret[ret.length - 1] instanceof _Formatter2.Token) {\n            ret.push(cur);\n          } else {\n            ret[ret.length - 1] += cur;\n          }\n        }\n      }\n\n      return ret;\n    }\n    /**\n     * Convert a moment into a formatted date string, using the format tokens defined at: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n     *\n     * @param {Moment} moment - the moment to convert\n     * @param {string} formatString - the format string\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(moment, formatString) {\n      var parts = this.tokenize(formatString);\n      var ret = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var part = _step.value;\n\n          if (part instanceof _Formatter2.Token) {\n            var partString = part.toString();\n            var translation = javaToMoment[partString];\n\n            if (translation === undefined) {\n              var err = new Error(\"'\".concat(partString, \"' cannot be converted to a moment format token; bailing\")); //          console.error(err.message);\n\n              throw err;\n            } else {\n              if (typeof translation === 'function') {\n                var result = translation(moment, partString);\n\n                if (result === null) {\n                  var _err = new Error(\"'\".concat(partString, \"' cannot be converted to a moment format token; bailing\")); //          console.error(err.message);\n\n\n                  throw _err;\n                }\n\n                ret.push(result);\n              } else {\n                ret.push(moment.format(translation));\n              }\n            }\n          } else {\n            ret.push(part);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return ret.join('');\n    }\n  }]);\n\n  return DateTimeFormatter;\n}(_Formatter2.Formatter);\n\nexports.default = DateTimeFormatter;\n\n//# sourceURL=webpack:///./src/formats/DateTimeFormatter.ts?");

/***/ }),

/***/ "./src/formats/SimpleDateFormat.ts":
/*!*****************************************!*\
  !*** ./src/formats/SimpleDateFormat.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Formatter2 = __webpack_require__(/*! ../Formatter */ \"./src/Formatter.ts\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar matchReserved = /[A-Za-z]/;\n\nvar eraFormatter = function eraFormatter(moment) {\n  return moment.year() > 0 ? 'AD' : 'BC';\n};\n\nvar guessZoneInfo = function guessZoneInfo(moment) {\n  var abbr = moment.zoneAbbr();\n  var name = moment.zoneName();\n\n  if (moment.tz) {\n    if (!name || name === '') {\n      // missing the zone name, probably can't find things right\n      return null;\n    }\n\n    if (abbr === 'UTC' && moment.utcOffset() !== 0) {\n      // we only know the offset\n      return null;\n    } // return name;\n\n\n    return {\n      abbr: abbr,\n      name: name,\n      description: (0, _Formatter2.getDescriptionForAbbreviation)(abbr)\n    };\n  }\n\n  abbr = (0, _Formatter2.getZoneForDateTime)(moment);\n\n  if (abbr) {\n    var match = (0, _Formatter2.getDescriptionForAbbreviation)(abbr);\n\n    if (match) {\n      return {\n        abbr: abbr,\n        name: name,\n        description: match\n      };\n    }\n  }\n\n  return null;\n};\n\nvar javaToMoment = {\n  // Era designator\n  G: eraFormatter,\n  GG: eraFormatter,\n  GGG: eraFormatter,\n  GGGG: eraFormatter,\n  // Year\n  y: function y(moment) {\n    return (0, _Formatter2.toAbsString)(moment.format('Y'));\n  },\n  yy: function yy(moment) {\n    return (0, _Formatter2.toAbsString)(moment.format('YY'));\n  },\n  yyy: function yyy(moment) {\n    return (0, _Formatter2.zeroPad)((0, _Formatter2.toAbsString)(moment.format('YYYY')), 3);\n  },\n  yyyy: function yyyy(moment) {\n    return (0, _Formatter2.toAbsString)(moment.format('YYYY'));\n  },\n  // Week year\n  Y: 'gggg',\n  YY: 'gg',\n  YYY: function YYY(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('gggg'), 3);\n  },\n  YYYY: 'gggg',\n  // Month in year\n  M: 'M',\n  MM: 'MM',\n  MMM: 'MMM',\n  MMMM: 'MMMM',\n  // Week in year\n  w: function w(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('w'), 1);\n  },\n  ww: function ww(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('w'), 2);\n  },\n  www: function www(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('w'), 3);\n  },\n  wwww: function wwww(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('w'), 4);\n  },\n  // Week in month (W) not supported\n  W: null,\n  WW: null,\n  WWW: null,\n  WWWW: null,\n  // Day in year\n  D: 'DDD',\n  DD: function DD(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('DDD'), 2);\n  },\n  DDD: function DDD(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('DDD'), 3);\n  },\n  DDDD: function DDDD(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('DDD'), 4);\n  },\n  // Day in month\n  d: 'D',\n  dd: 'DD',\n  ddd: function ddd(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('D'), 3);\n  },\n  dddd: function dddd(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('D'), 4);\n  },\n  // Day of week in month (F) not supported\n  F: null,\n  FF: null,\n  FFF: null,\n  FFFF: null,\n  // Day name in week\n  E: 'ddd',\n  EE: 'ddd',\n  EEE: 'ddd',\n  EEEE: 'dddd',\n  // Day number of week\n  u: 'E',\n  uu: function uu(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('E'), 2);\n  },\n  uuu: function uuu(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('E'), 3);\n  },\n  uuuu: function uuuu(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('E'), 4);\n  },\n  // Am/pm marker\n  a: 'A',\n  aa: 'A',\n  aaa: 'A',\n  aaaa: 'A',\n  // Hour in day (0-23)\n  H: 'H',\n  HH: 'HH',\n  HHH: function HHH(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('H'), 3);\n  },\n  HHHH: function HHHH(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('H'), 4);\n  },\n  // Hour in day (1-24)\n  k: 'k',\n  kk: 'kk',\n  kkk: function kkk(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('k'), 3);\n  },\n  kkkk: function kkkk(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('k'), 4);\n  },\n  // Hour in am/pm (0-11)\n  // except java doesn't actually do this, it outputs the same as 'h'!  (sigh)\n  K: function K(moment) {\n    var asNumber = parseInt(moment.format('h'), 10);\n    return (0, _Formatter2.toAbsString)(asNumber % 12);\n  },\n  KK: function KK(moment) {\n    var asNumber = parseInt(moment.format('h'), 10);\n    return (0, _Formatter2.zeroPad)((0, _Formatter2.toAbsString)(asNumber % 12), 2);\n  },\n  KKK: function KKK(moment) {\n    var asNumber = parseInt(moment.format('h'), 10);\n    return (0, _Formatter2.zeroPad)((0, _Formatter2.toAbsString)(asNumber % 12), 3);\n  },\n  KKKK: function KKKK(moment) {\n    var asNumber = parseInt(moment.format('h'), 10);\n    return (0, _Formatter2.zeroPad)((0, _Formatter2.toAbsString)(asNumber % 12), 4);\n  },\n  // Hour in am/pm (1-12)\n  h: 'h',\n  hh: 'hh',\n  hhh: function hhh(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('h'), 3);\n  },\n  hhhh: function hhhh(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('h'), 4);\n  },\n  // Minute in hour\n  m: 'm',\n  mm: 'mm',\n  mmm: function mmm(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('m'), 3);\n  },\n  mmmm: function mmmm(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('m'), 4);\n  },\n  // Second in minute\n  s: 's',\n  ss: 'ss',\n  sss: function sss(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('s'), 3);\n  },\n  ssss: function ssss(moment) {\n    return (0, _Formatter2.zeroPad)(moment.format('s'), 4);\n  },\n  // Millisecond\n  S: 'S',\n  SS: 'SS',\n  SSS: 'SSS',\n  SSSS: 'SSSS',\n  // Time zone (Pacific Standard Time; PST)\n  z: function z(moment) {\n    var info = guessZoneInfo(moment);\n\n    if (info) {\n      return info.abbr;\n    }\n\n    return 'GMT' + moment.format('Z');\n  },\n  zz: function zz(moment) {\n    var info = guessZoneInfo(moment);\n\n    if (info) {\n      return info.abbr;\n    }\n\n    return 'GMT' + moment.format('Z');\n  },\n  zzz: function zzz(moment) {\n    var info = guessZoneInfo(moment);\n\n    if (info) {\n      return info.abbr;\n    }\n\n    return 'GMT' + moment.format('Z');\n  },\n  zzzz: function zzzz(moment) {\n    var info = guessZoneInfo(moment);\n\n    if (info) {\n      return info.description;\n    }\n\n    return 'GMT' + moment.format('Z');\n  },\n  // Time zone (-0800)\n  Z: 'ZZ',\n  ZZ: 'ZZ',\n  ZZZ: 'ZZ',\n  ZZZZ: 'ZZ',\n  // Time zone (-08; -0800; -08:00)\n  X: function X(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    return moment.format('Z').substr(0, 3);\n  },\n  XX: function XX(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    return moment.format('ZZ');\n  },\n  XXX: function XXX(moment) {\n    if (moment.utcOffset() === 0) {\n      return 'Z';\n    }\n\n    return moment.format('Z');\n  }\n};\n\nvar SimpleDateFormat =\n/*#__PURE__*/\nfunction (_Formatter) {\n  _inherits(SimpleDateFormat, _Formatter);\n\n  function SimpleDateFormat() {\n    _classCallCheck(this, SimpleDateFormat);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SimpleDateFormat).apply(this, arguments));\n  }\n\n  _createClass(SimpleDateFormat, [{\n    key: \"tokenize\",\n    value: function tokenize(pattern) {\n      var ret = [];\n      var length = pattern.length;\n      var inQuote = false;\n      var count = 0;\n      var lastTag = null;\n      var tmpBuffer = null;\n\n      var encode = function encode(tag, length) {\n        var translate = javaToMoment[tag];\n\n        if (translate === null) {\n          throw new Error(\"'\".concat(tag.repeat(length), \"' cannot be converted to a moment format token; token is not implemented\"));\n        } else if (translate === undefined) {\n          throw new Error(\"'\".concat(tag.repeat(length), \"' cannot be converted to a moment format token; unknown token\"));\n        }\n\n        ret.push(new _Formatter2.Token(tag, length));\n      };\n\n      var append = function append(value) {\n        if (ret[ret.length - 1] instanceof _Formatter2.Token) {\n          ret.push(value);\n        } else {\n          ret[ret.length - 1] += value;\n        }\n      };\n\n      for (var i = 0; i < length; i++) {\n        var c = pattern.charAt(i);\n\n        if (c === '\\'') {\n          // '' is treated as a single quote regardless of being\n          // in a quoted section.\n          if (i + 1 < length) {\n            c = pattern.charAt(i + 1);\n\n            if (c === '\\'') {\n              i++;\n\n              if (count != 0) {\n                encode(lastTag, count);\n                lastTag = null;\n                count = 0;\n              }\n\n              if (inQuote) {\n                tmpBuffer += c;\n              } else {\n                append(c);\n              }\n\n              continue;\n            }\n          }\n\n          if (!inQuote) {\n            if (count !== 0) {\n              encode(lastTag, count);\n              lastTag = null;\n              count = 0;\n            }\n\n            tmpBuffer = '';\n            inQuote = true;\n          } else {\n            append(tmpBuffer);\n            inQuote = false;\n          }\n\n          continue;\n        }\n\n        if (inQuote) {\n          tmpBuffer += c;\n          continue;\n        }\n\n        if (!c.match(matchReserved)) {\n          if (count !== 0) {\n            encode(lastTag, count);\n            lastTag = null;\n            count = 0;\n          }\n\n          if (c.charCodeAt(0) < 128) {\n            // In most cases, c would be a delimiter, such as ':'.\n            append(c);\n          } else {\n            // Take any contiguous non-ASCII alphabet characters and\n            // put them in a single TAG_QUOTE_CHARS.\n            var j = void 0;\n\n            for (j = i + 1; j < length; j++) {\n              var d = pattern.charAt(j);\n\n              if (d === '\\'' || d.match(matchReserved)) {\n                break;\n              }\n            }\n\n            for (; i < j; i++) {\n              append(pattern.charAt(i));\n            }\n\n            i--;\n          }\n\n          continue;\n        }\n\n        var tag = javaToMoment[c];\n\n        if (tag === undefined) {\n          throw new Error(\"Illegal pattern character '\".concat(c, \"'\"));\n        }\n\n        if (lastTag === null || lastTag === c) {\n          lastTag = c;\n          count++;\n          continue;\n        }\n\n        encode(lastTag, count);\n        lastTag = c;\n        count = 1;\n      }\n\n      if (inQuote) {\n        throw new Error('Unterminated quote');\n      }\n\n      if (count != 0) {\n        encode(lastTag, count);\n      }\n\n      return ret;\n    }\n    /**\n     * Convert a moment into a formatted date string, using the format tokens defined at: https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html\n     *\n     * @param {Moment} moment - the moment to convert\n     * @param {string} formatString - the format string\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(moment, formatString) {\n      var parts = this.tokenize(formatString);\n      var ret = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var part = _step.value;\n\n          if (part instanceof _Formatter2.Token) {\n            var partString = part.toString();\n            var translation = javaToMoment[partString];\n\n            if (translation === undefined) {\n              throw new Error(\"'\".concat(partString, \"' cannot be converted to a moment format token; unknown token\"));\n            } else {\n              if (typeof translation === 'function') {\n                ret.push(translation(moment, partString));\n              } else {\n                ret.push(moment.format(translation));\n              }\n            }\n          } else {\n            ret.push(part);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return ret.join('');\n    }\n  }]);\n\n  return SimpleDateFormat;\n}(_Formatter2.Formatter);\n\nexports.default = SimpleDateFormat;\n\n//# sourceURL=webpack:///./src/formats/SimpleDateFormat.ts?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"SimpleDateFormat\", {\n  enumerable: true,\n  get: function get() {\n    return _SimpleDateFormat.default;\n  }\n});\nObject.defineProperty(exports, \"DateTimeFormatter\", {\n  enumerable: true,\n  get: function get() {\n    return _DateTimeFormatter.default;\n  }\n});\nexports.register = exports.default = void 0;\n\nvar _SimpleDateFormat = _interopRequireDefault(__webpack_require__(/*! ./formats/SimpleDateFormat */ \"./src/formats/SimpleDateFormat.ts\"));\n\nvar _DateTimeFormatter = _interopRequireDefault(__webpack_require__(/*! ./formats/DateTimeFormatter */ \"./src/formats/DateTimeFormatter.ts\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable @typescript-eslint/no-var-requires */\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\nvar register = function register(moment) {\n  var fatal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (moment && moment.fn.zoneAbbr) {\n    console.log('register:', moment, fatal);\n\n    if (moment.tz) {\n      console.log('Moment.js with timezone support detected; attaching Java format methods.');\n    } else {\n      console.warn('Moment.js detected, but timezone support is missing.  Some Java formatting features may not work as expected.');\n    }\n\n    var sdf = new _SimpleDateFormat.default();\n    var dtf = new _DateTimeFormatter.default();\n\n    moment.fn.formatJavaSDF = function (formatString) {\n      return sdf.format(this, formatString);\n    };\n\n    moment.fn.formatJavaDTF = function (formatString) {\n      return dtf.format(this, formatString);\n    };\n\n    return moment;\n  } else {\n    console.error('Unable to attach Java format methods.  Moment.js object was invalid.');\n\n    if (fatal) {\n      throw new Error('Moment.js object was invalid.');\n    }\n  }\n\n  return undefined;\n};\n/*\n  Attempt to register with global Moment.js object if it's found,\n  preferring `moment-timezone` over `moment`.\n*/\n\n\nexports.register = register;\n\nif (window.moment) {\n  register(window.moment, false);\n} else {\n  try {\n    var moment = __webpack_require__(/*! moment-timezone */ \"moment-timezone\");\n\n    window.moment = register(moment, false);\n  } catch (err) {\n    console.warn('Failed to load moment-timezone. Attempting fallback to moment.');\n\n    try {\n      var _moment = __webpack_require__(/*! moment */ \"moment\");\n\n      window.moment = register(_moment, false);\n    } catch (subErr) {\n      console.warn('Failed to load moment.  User will have to manually register.');\n    }\n  }\n}\n\nvar _default = window.moment ? window.moment : undefined;\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "moment":
/*!*************************!*\
  !*** external "moment" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if(typeof __WEBPACK_EXTERNAL_MODULE_moment__ === 'undefined') {var e = new Error(\"Cannot find module 'moment'\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_moment__;\n\n//# sourceURL=webpack:///external_%22moment%22?");

/***/ }),

/***/ "moment-timezone":
/*!**********************************!*\
  !*** external "moment-timezone" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if(typeof __WEBPACK_EXTERNAL_MODULE_moment_timezone__ === 'undefined') {var e = new Error(\"Cannot find module 'moment-timezone'\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_moment_timezone__;\n\n//# sourceURL=webpack:///external_%22moment-timezone%22?");

/***/ })

/******/ });
});